<html>
<head>
  <title>11--组件 API</title>
  <basefont face="Consolas" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600363 (zh-CN, DDL); Windows/6.1.1 (Win64);"/>
  <style>
    body, td {
      font-family: Consolas;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1408"/>
<h1>11--组件 API</h1>

<div>
<span><div><div><b>React 组件 API</b></div><div><br/></div><div>在本章中我们将讨论 React 组件 API, 我们将讲解七个办法.</div><ul><li><div>设置状态: setState</div></li><li><div>替换状态: replaceState</div></li><li><div>设置属性: setProps</div></li><li><div>替换属性: replaceProps</div></li><li><div>强制更新: forceUpdate</div></li><li><div>获取 DOM 节点: findDOMNode</div></li><li><div>判断组件挂载状态: isMounted</div></li></ul><div><b><br/></b></div><div><b>1.设置状态: setState</b></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">setState(object nextState[, function callback])</span></div></div><div><br/></div><div><b>参数说明</b></div><ul><li><div>nextState, 将要设置的新状态, 该状态会和当前的 state 合并</div></li><li><div>callback, 可选参数, 回调函数. 该函数会在 setState 设置成功, 且组件重新渲染后调用.</div></li></ul><div>合并 nextState 和当前 state, 并重新渲染组件. setState 是 React 事件处理函数中和请求回调函数中触发 UI 更新的主要方法.</div><div><br/></div><div><b>关于 setState</b></div><div><br/></div><div>不能在组件内部通过 this.state 修改状态, 因为该状态会在调用 setState() 后被替换.</div><div>setState() 并不会立即改变 this.state, 而是创建一个即将处理的 state. setState() 并不一定是同步的, 为了提升性能 React 会批量执行 state 和 DOM 渲染.</div><div>setState() 总是会触发一次组件重绘, 除非在 shouldComponentUpdate() 中实现了一些条件渲染逻辑.</div><div><br/></div><div><b>实例</b></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class Counter extends</span> <a href="http://react.component/" style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">React.Component</a><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  constructor(props) {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">      super(props);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">      this.state = {clickCount: 0};</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">      this.handleClick = this.handleClick.bind(this);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  }</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  handleClick() {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    this.setState(function(state) {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">      return {clickCount: state.clickCount + 1};</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    });</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  }</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  render () {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    return (&lt;h2 onClick={this.handleClick}&gt;点我！点击次数为: {this.state.clickCount}&lt;/h2&gt;);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  }</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">ReactDOM.render(</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  &lt;Counter /&gt;,</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  document.getElementById('example')</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">);</span></div></div><div><br/></div><div>实例中通过点击 h2 标签来使得点击计数器加 1</div><div><br/></div><div><b>2.替换状态: replaceState</b></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">replaceState(object nextState[, function callback])</span></div></div><div><br/></div><ul><li><div>nextState, 将要设置的新状态, 该状态会替换当前的 state</div></li><li><div>callback, 可选参数, 回调函数, 该函数会在 replaceState 设置成功, 且组件重新渲染后调用.</div></li></ul><div>replaceState() 方法与 setState() 类似, 但方法只会保留 nextState 中状态, 原 state 不在 nextState 中的状态都会被删除.</div><div><br/></div><div><b>3.设置属性: setProps</b></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">setProps(object nextProps[, function callback])</span></div></div><div><br/></div><ul><li><div>nextProps, 将要设置的新属性, 该状态会和当前的 props 合并</div></li><li><div>callback, 可选参数, 回调函数. 该函数会在 setProps 设置成功, 且组件重新渲染后调用.</div></li></ul><div><br/></div><div>设置组件属性, 并重新渲染组件.</div><div>props 相当于组件的数据流, 它总是会从父组件向下传递至所有的子组件中. 当和一个外部的 JavaScript 应用集成时, 我们可能会需要向组件传递数据或通知 React.render() 组件需要重新渲染, 可以使用 setProps().</div><div>更新组件, 我可以在节点上再次调用 React.render(), 也可以通过 setProps() 方法改变组件属性, 触发组件重新渲染.</div><div><br/></div><div><b>4.替换属性: replaceProps</b></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">replaceProps(object nextProps[, function callback])</span></div></div><div><br/></div><ul><li><div>nextProps, 将要设置的新属性, 该属性会替换当前的 props.</div></li><li><div>callback, 可选参数, 回调函数. 该函数会在 replaceProps 设置成功, 且组件重新渲染后调用.</div></li></ul><div><br/></div><div>replaceProps() 方法与 setProps 类似, 但它会删除原有 props.</div><div><br/></div><div><b>5.强制更新: forceUpdate</b></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">forceUpdate([function callback])</span></div></div><div><br/></div><ul><li><div>callback, 可选参数, 回调函数. 该函数会在组件 render() 方法调用后调用.</div></li></ul><div><br/></div><div>forceUpdate() 方法会使组件调用自身的 render() 方法重新渲染组件, 组件的子组件也会调用自己的 render(). 但是, 组件重新渲染时, 依然会读取 this.props 和 this.state, 如果状态没改变, 那么 React 只会更新 DOM.</div><div>forceUpdate() 方法适用于 this.props 和 this.state 之外的组件重绘 (如: 修改了 this.state 后), 通过该方法通知 React 需要调用 render()</div><div>一般来说, 应该尽量避免使用 forceUpdate(), 而仅从 this.props 和 this.state 中读取状态并由 React 触发 render() 调用.</div><div><b><br/></b></div><div><b>6.获取 DOM 节点: findDOMNode</b></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">DOMElement findDOMNode()</span></div></div><div><br/></div><ul><li><div>返回值: DOM 元素 DOMElement</div></li></ul><div><br/></div><div>如果组件已经挂载到 DOM 中, 该方法返回对应的本地浏览器 DOM 元素. 当 render 返回 null 或 false 时, this.findDOMNode() 也会返回 null. 从 DOM 中读取值得时候, 该方法很有用, 如: 获取表单字段的值和做一些 DOM 操作.</div><div><b><br/></b></div><div><b>7.判断组件挂载状态: isMounted</b></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">bool isMounted()</span></div></div><div><br/></div><ul><li><div>返回值, true/false, 表示组件是否已经挂载到 DOM 中</div></li></ul><div><br/></div><div>isMounted() 方法用于判断组件是否已挂载到 DOM 中, 可以使用该方法保证了 setState() 和 forceUpdate() 在异步场景下的调用不会出错.</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></div></span>
</div></body></html> 