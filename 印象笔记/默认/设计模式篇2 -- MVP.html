<html>
<head>
  <title>设计模式篇2 -- MVP</title>
  <basefont face="Consolas" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600363 (zh-CN, DDL); Windows/6.1.1 (Win64);"/>
  <style>
    body, td {
      font-family: Consolas;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="2012"/>
<h1>设计模式篇2 -- MVP</h1>

<div>
<span><div><div><font color="#797979">MVP ( Model-View-Presenter )</font></div><div><font color="#797979"><br/></font></div><div><font color="#797979">MVP 是从经典的 MVC 架构演变而来, </font></div><div><font color="#797979"><br/></font></div><div><span style="font-weight: bold;"><font color="#797979">MVP 有什么好处,我们为什么要用 MVP ?</font></span></div><div><font color="#797979"><br/></font></div><ul><li><div><font color="#797979">代码解耦</font></div></li><li><div><font color="#797979">结构清晰</font></div></li><li><div><font color="#797979">可复用</font></div></li><li><div><font color="#797979">扩展性高</font></div></li><li><div><font color="#797979">方便进行单元测试</font></div></li></ul><div><font color="#797979"><br/></font></div><div><font color="#797979">在 MVP 中 View 并不直接使用 Model ,它们之间的通信是通过 Presenter ( MVC 中的 Controller ) 来进行的,所有的交互都发生在 Presenter 内部,而在 MVC 中 View 会从直接 Model 中读取数据而不是通过 Controller.</font></div><div><font color="#797979"><br/></font></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><font color="#797979">    在 MVP 里, Presenter 完全把 Model 和 View 进行了分离,主要的程序逻辑在 Presenter 里实现.而且, Presenter 与具体的 View 是没有直接关联的,而是通过接口进行交互,从而使得在变更 View 时候可以保持 Presenter 的不变,可以多次复用.</font></span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><font color="#797979">    在 MVP 里, 应用程序的逻辑主要在 Presenter 来实现,其中的 View 是很薄的一层,只应该有简单的 Set/Get 的方法,用户输入和设置界面显示的内容,除此就不应该有更多的内容,绝不容许直接访问 Model.</font></span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><font color="#797979">    MVP 主要解决的就是把逻辑层抽出来成 P 层,要是遇到需求逻辑上的更改就可以只需要修改 P 层了或遇到逻辑上的大改我们可以直接重写一个 P 也可以,很多开发人员把所有的东西都写在了 Activity/Fragment 里面这样一来遇到频繁改需求或者逻辑越来越复杂的时候, Activity/Fragment 里面出现过多的混杂逻辑导致出错,所以 MVP 模式对于 APP 来对控制逻辑和 UI 的解耦来说是一个不错的选择.</font></span></div><div><font color="#797979"><br/></font></div><div><font color="#797979">上面说逻辑是在 Presenter 中处理的,假设这是一个登录界面,如要输入账号密码,那么对账号密码的是否为空判断以及正则表达式等也需要放入 Persenter 中,毕竟这些都是逻辑.</font></div><div><font color="#797979">然后判断成功的话,( 下面的操作都是在 Presenter 中进行的 ) ,先调用 view 层的方法,让 ProgressDialog 显示出来,然后调用 Model 层的网络请求,结果的话在 presenter 中回调.在回调里面分别做 ProgressDialog 消失的处理,然后成功的话调用 view 层的方法,进入主界面,失败的话调用 view 层的方法,提示失败 Toast 之类的.</font></div><div><font color="#797979"><br/></font></div><div><span style="font-weight: bold;"><font color="#797979">MVP 是什么?怎么实现?</font></span></div><div><font color="#797979"><br/></font></div><div><font color="#797979"><img src="设计模式篇2 -- MVP_files/MVP 示例.jpg" type="image/jpeg" data-filename="MVP 示例.jpg"/></font></div><div><font color="#797979"><br/></font></div><div><font color="#797979">首先介绍下每个类是干嘛的：</font></div><ul><li><div><font color="#797979">BuyBooActivity是我们的Activity</font></div></li><li><div><font color="#797979">BaseActivity是Activity的基类</font></div></li><li><div><font color="#797979">BasePresenter是Presenter的基类</font></div></li><li><div><font color="#797979">BuyBookBean是我们的bean，也就是传说中的实体类，几个成员变量，自动生成一堆get、set方法的那个类</font></div></li><li><div><font color="#797979">IBuyBookView也就是BuyBooActivity的接口</font></div></li><li><div><font color="#797979">BuyBookPresenter也就是这个Actvity的Presenter</font></div></li><li><div><font color="#797979">IBuyBookPresenter是BuyBookPresenter的接口</font></div></li><li><div><font color="#797979">BuyBookModel是这个Activity的数据层</font></div></li><li><div><font color="#797979">IBuyBookModel是BuyBookModel的接口</font></div></li><li><div><font color="#797979">BuyBookAdapter是BuyBooActivity里面ListView的适配器</font></div></li><li><div><font color="#797979">ValueCallBack，是一个通用的回调接口</font></div></li></ul><div><font color="#797979"><br/></font></div></div><div><font color="#797979">这里接口都是以 I 开头,每个 model, presenter, 还有 Activity 的 view, 都对应着一个接口, 有些人可能会问,干嘛写接口, 一下多了这么多类, 看的都懵逼了</font></div><div><font color="#797979"><br/></font></div><div><span style="font-weight: bold;"><font color="#797979">为什么写接口?</font></span></div><div><font color="#797979"><br/></font></div><div><font color="#797979">问这个问题应该去复习设计模式的六大基本原则了,我们要控制项目而不是项目控制我们,我们要进行的是面向接口的编程,用抽象 ( 或者接口 ) 搭建框架,用实现扩展细节.当然接口也不能滥用,都要看具体情况,这里是按照最高标准来写</font></div><div><font color="#797979"><br/></font></div><div><font color="#797979">google官方 MVP 示例项目是把上面的 IBuyBookPresenter 以及 IBuyBookView 这两个接口放到了 IBuyBookContract 这个协议类中,实际上是一样的,这就看个人喜好了,各有各的优缺点,比如把本例子的代码改成协议类的这种就如下代码所示</font></div><div><font color="#797979"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font color="#797979">1. public interface IBuyBookContract  </font></div><div><font color="#797979">2. {  </font></div><div><font color="#797979">3.     interface IBuyBookView  </font></div><div><font color="#797979">4.     {  </font></div><div><font color="#797979">5.         void showToast(String msg);  </font></div><div><font color="#797979">6.   </font></div><div><font color="#797979">7.         void refreshAdapter();  </font></div><div><font color="#797979">8.   </font></div><div><font color="#797979">9.         void onEmpty();  </font></div><div><font color="#797979">10.     }  </font></div><div><font color="#797979">11.   </font></div><div><font color="#797979">12.     interface IBuyBookPresenter  </font></div><div><font color="#797979">13.     {  </font></div><div><font color="#797979">14.   </font></div><div><font color="#797979">15.         List&lt;BuyBookBean&gt; getAdapterData();  </font></div><div><font color="#797979">16.     }  </font></div><div><font color="#797979">17. }  </font></div></div><div><font color="#797979"><br/></font></div><div><span style="font-weight: bold;"><font color="#797979">M ( Model )</font></span></div><div><font color="#797979">数据层,和 MVC 中的 M 一样,用来存放数据的处理 ( 比如网络请求,缓存等 )</font></div><div><font color="#797979"><br/></font></div><div><span style="font-weight: bold;"><font color="#797979">V ( View )</font></span></div><div><font color="#797979">负责 UI 具体实现展现,比如 Presenter 派发过来一个动作是 showDialog 显示进度命令,那么我们这个 View 就负责实现具体 UI</font></div><div><font color="#797979"><br/></font></div><div><span style="font-weight: bold;"><font color="#797979">P ( Presenter )</font></span></div><div><font color="#797979">负责处理业务逻辑代码,处理 Model 数据,然后将处理完的数据分发到 View 层</font></div><div><font color="#797979"><br/></font></div><div><font color="#797979"><br/></font></div><div><font color="#797979">View 中的 IBuyBookView</font></div><div><font color="#797979">这里主要包含了 Activity 的一系列关于 UI 的操作,然后我们的 Activity 是实现,这样 Presenter 就可以调用了</font></div><div><font color="#797979"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font color="#797979">1. public interface IBuyBookView {  </font></div><div><font color="#797979">2.     /**</font></div><div><font color="#797979">3.      * 提示toast</font></div><div><font color="#797979">4.      */  </font></div><div><font color="#797979">5.     void showToast(String msg);  </font></div><div><font color="#797979">6.   </font></div><div><font color="#797979">7.     /**</font></div><div><font color="#797979">8.      * 刷新adapter</font></div><div><font color="#797979">9.      */  </font></div><div><font color="#797979">10.     void refreshAdapter();  </font></div><div><font color="#797979">11.   </font></div><div><font color="#797979">12.     void onEmpty();  </font></div><div><font color="#797979">13. }  </font></div></div><div><font color="#797979"><br/></font></div><div><font color="#797979">接下来讲 Model 的 IBuyBookModel</font></div><div><font color="#797979">主要是写了几个方法供 BuyBokModel 去实现</font></div><div><font color="#797979"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font color="#797979">1. public interface IBuyBookModel {  </font></div><div><font color="#797979">2.     /**</font></div><div><font color="#797979">3.      * 获取模拟数据</font></div><div><font color="#797979">4.      */  </font></div><div><font color="#797979">5.     void getTestData(ValueCallBack&lt;List&lt;BuyBookBean&gt;&gt; callBack);  </font></div><div><font color="#797979">6.   </font></div><div><font color="#797979">7.   </font></div><div><font color="#797979">8.     /**</font></div><div><font color="#797979">9.      * 返回本地adapter数据</font></div><div><font color="#797979">10.      * @return</font></div><div><font color="#797979">11.      */  </font></div><div><font color="#797979">12.     List&lt;BuyBookBean&gt; getAdapterData();  </font></div><div><font color="#797979">13. }  </font></div></div><div><font color="#797979"><br/></font></div><div><font color="#797979"> 这里实现了 IBuyBookModel ,然后模拟了下网络请求,用随机数来模拟请求成功与失败</font></div><div><font color="#797979"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font color="#797979">1. public class BuyBookModel implements IBuyBookModel {  </font></div><div><font color="#797979">2.     private List&lt;BuyBookBean&gt; listData;  </font></div><div><font color="#797979">3.   </font></div><div><font color="#797979">4.   </font></div><div><font color="#797979">5.     public BuyBookModel() {  </font></div><div><font color="#797979">6.         this.listData = new ArrayList&lt;&gt;();  </font></div><div><font color="#797979">7.     }  </font></div><div><font color="#797979">8.   </font></div><div><font color="#797979">9.     @Override  </font></div><div><font color="#797979">10.     public void getTestData(final ValueCallBack&lt;List&lt;BuyBookBean&gt;&gt; callBack) {  </font></div><div><font color="#797979">11.         new Handler().postDelayed(new Runnable() {  </font></div><div><font color="#797979">12.             @Override  </font></div><div><font color="#797979">13.             public void run() {  </font></div><div><font color="#797979">14.                 List&lt;BuyBookBean&gt; list = new ArrayList&lt;&gt;();  </font></div><div><font color="#797979">15.                 list.add(new BuyBookBean(&quot;赵云&quot;, 1, &quot;09-27 09:11&quot;));  </font></div><div><font color="#797979">16.                 list.add(new BuyBookBean(&quot;赵云、典韦、貂蝉、林芳、曹操、刘备、关羽、黄忠、张飞、诸葛孔明&quot;, 10, &quot;09-27 09:11&quot;));  </font></div><div><font color="#797979">17.                 list.add(new BuyBookBean(&quot;黄忠、孙权、大乔&quot;, 50, &quot;09-27 09:11&quot;));  </font></div><div><font color="#797979">18.                 list.add(new BuyBookBean(&quot;大乔、小乔、貂蝉、孙尚香&quot;, 300, &quot;09-27 09:11&quot;));  </font></div><div><font color="#797979">19.   </font></div><div><font color="#797979">20.                 Random rd = new Random();  </font></div><div><font color="#797979">21.                 int N = rd.nextInt(10);  </font></div><div><font color="#797979">22.                 if (N &gt; 5) {  </font></div><div><font color="#797979">23.                     callBack.onSuccess(list);  </font></div><div><font color="#797979">24.                 } else {  </font></div><div><font color="#797979">25.                     callBack.onFail(&quot;拒绝请求&quot;);  </font></div><div><font color="#797979">26.                 }  </font></div><div><font color="#797979">27.             }  </font></div><div><font color="#797979">28.         }, 1000);  </font></div><div><font color="#797979">29.     }  </font></div><div><font color="#797979">30.   </font></div><div><font color="#797979">31.   </font></div><div><font color="#797979">32.     @Override  </font></div><div><font color="#797979">33.     public List&lt;BuyBookBean&gt; getAdapterData() {  </font></div><div><font color="#797979">34.         return listData;  </font></div><div><font color="#797979">35.     }  </font></div><div><font color="#797979">36. }  </font></div></div><div><font color="#797979"><br/></font></div><div><font color="#797979">回调接口,这里使用了泛型,为了多多复用</font></div><div><font color="#797979"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font color="#797979">1. public interface ValueCallBack&lt;T&gt; {  </font></div><div><font color="#797979">2.     void onSuccess(T t);  </font></div><div><font color="#797979">3.   </font></div><div><font color="#797979">4.     void onFail(String code);  </font></div><div><font color="#797979">5. }  </font></div></div><div><font color="#797979"><br/></font></div><div><font color="#797979">接下来讲 Presenter 的 BasePresenter 等类</font></div><div><font color="#797979">这个是所有 Presenter 的基类,里面有个 initData() 方法,基本每个 Presenter 都要处理网络请求,所以就弄了这么一个基类,至于为什么是抽象类而不是接口,是因为抽象类方便,如果我们向抽象类中添加新的方法 ( 该方法不是抽象的 ) ,可以给他提供默认的实现,而且不要修改现有的代码,但是如果是接口的话,就要修改现有的代码了.</font></div><div><font color="#797979"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font color="#797979">1. public abstract class BasePresenter&lt;T extends BaseActivity&gt; {  </font></div><div><font color="#797979">2.   </font></div><div><font color="#797979">3.     abstract void initData();  </font></div><div><font color="#797979">4. }  </font></div></div><div><font color="#797979"><br/></font></div><div><font color="#797979">这里主要写了个方法,以供 BuyBookPresenter 实现</font></div><div><font color="#797979"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font color="#797979">1. public interface IBuyBookPresenter {  </font></div><div><font color="#797979">2.   </font></div><div><font color="#797979">3.     List&lt;BuyBookBean&gt; getAdapterData();  </font></div><div><font color="#797979">4. }  </font></div></div><div><font color="#797979"><br/></font></div><div><font color="#797979">这里首先实现了 IBuyBookPesenter 继承了 BasePresenter, 然后重写了一些方法.这里的 <span style="font-weight: bold;">构造方法 </span>是重点,在构造方法中我们需要传入一个 IBookView ,实际上我们的 Activity 已经实现 IBookView 了, 所以这里实际上传的是具体的 Activity,也就是 this 就行了.然后 model 我们就可以直接 new 出来用, 这里就是 new 了.</font></div><div><font color="#797979"><br/></font></div><div><font color="#797979">在 initData 中我们进行了具体的网络请求, 网络请求我们是不是要弹出一个 Dialog 出来, 直接在这 mView.loading(); 调用就行了.然后请求成功 onSuccess() 里面让 Dialog 消失,提醒适配器刷新.失败的话 onFail( ) 里面提示 Dialog 消失, 然后在 ListView 设置失败页面</font></div><div><font color="#797979"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font color="#797979">1. public class BuyBookPresenter extends BasePresenter&lt;BuyBookActivity&gt; implements IBuyBookPresenter {  </font></div><div><font color="#797979">2.   </font></div><div><font color="#797979">3.     private IBuyBookView  mView;  </font></div><div><font color="#797979">4.     private IBuyBookModel mModel;  </font></div><div><font color="#797979">5.   </font></div><div><font color="#797979">6.     public BuyBookPresenter(IBuyBookView iBuyBookView) {  </font></div><div><font color="#797979">7.         this.mView = iBuyBookView;  </font></div><div><font color="#797979">8.         this.mModel = new BuyBookModel();  </font></div><div><font color="#797979">9.     }  </font></div><div><font color="#797979">10.   </font></div><div><font color="#797979">11.   </font></div><div><font color="#797979">12.     @Override  </font></div><div><font color="#797979">13.     public List&lt;BuyBookBean&gt; getAdapterData() {  </font></div><div><font color="#797979">14.         return mModel.getAdapterData();  </font></div><div><font color="#797979">15.     }  </font></div><div><font color="#797979">16.   </font></div><div><font color="#797979">17.     @Override  </font></div><div><font color="#797979">18.     public void initData() {  </font></div><div><font color="#797979">19.         //在这里弹出loading  </font></div><div><font color="#797979">20.         mModel.getTestData(new ValueCallBack&lt;List&lt;BuyBookBean&gt;&gt;() {  </font></div><div><font color="#797979">21.             @Override  </font></div><div><font color="#797979">22.             public void onSuccess(List&lt;BuyBookBean&gt; buyBookBeen) {  </font></div><div><font color="#797979">23.                 //在这里取消loading  </font></div><div><font color="#797979">24.                 //简单数据操作可以在presenter里完成  </font></div><div><font color="#797979">25.                 mModel.getAdapterData().addAll(buyBookBeen);  </font></div><div><font color="#797979">26.                 mView.refreshAdapter();  </font></div><div><font color="#797979">27.             }  </font></div><div><font color="#797979">28.   </font></div><div><font color="#797979">29.             @Override  </font></div><div><font color="#797979">30.             public void onFail(String code) {  </font></div><div><font color="#797979">31.                 //在这里取消loading  </font></div><div><font color="#797979">32.                 mView.showToast(code);  </font></div><div><font color="#797979">33.                 mView.onEmpty();  </font></div><div><font color="#797979">34.             }  </font></div><div><font color="#797979">35.         });  </font></div><div><font color="#797979">36.     }  </font></div><div><font color="#797979">37. }  </font></div></div><div><font color="#797979"><br/></font></div><div><font color="#797979">接下来讲 Activity 的基类, 可以看见这里有个泛型.这个泛型还必须集成 BasePresenter ,这个首先为了让人看到就知道对应那个 Presenter; 其次最重要的就是为了下面那个成员变量 basepresenter, 我们写一个抽象的方法要求返回泛型 T,而这个泛型 T 又继承了 BasePresenter ,那么我们就得到了具体 Presenter 的成员,可以直接用这个成员变量来调用 Presenter 中的方法了</font></div><div><font color="#797979"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font color="#797979">1. public abstract class BaseActivity&lt;T extends BasePresenter&gt; extends Activity {  </font></div><div><font color="#797979">2.       </font></div><div><font color="#797979">3.     protected T basepresenter;  </font></div><div><font color="#797979">4.   </font></div><div><font color="#797979">5.     @Override  </font></div><div><font color="#797979">6.     protected void onCreate(Bundle savedInstanceState) {  </font></div><div><font color="#797979">7.         super.onCreate(savedInstanceState);  </font></div><div><font color="#797979">8.         setContentView(getLayout());  </font></div><div><font color="#797979">9.         initView();  </font></div><div><font color="#797979">10.         basepresenter = initPresent();  </font></div><div><font color="#797979">11.         onPrepare();  </font></div><div><font color="#797979">12.     }  </font></div><div><font color="#797979">13.   </font></div><div><font color="#797979">14.     abstract T initPresent();  </font></div><div><font color="#797979">15.   </font></div><div><font color="#797979">16.     abstract int getLayout();  </font></div><div><font color="#797979">17.   </font></div><div><font color="#797979">18.     abstract void initView();  </font></div><div><font color="#797979">19.   </font></div><div><font color="#797979">20.     abstract void onPrepare();  </font></div><div><font color="#797979">21. }  </font></div></div><div><font color="#797979"><br/></font></div><div><font color="#797979">这个就是最终具体的 Activity 了,可以看到这里面都没什么逻辑,基本都是一些重写的方法</font></div><div><font color="#797979"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font color="#797979">1. public class BuyBookActivity extends BaseActivity&lt;BuyBookPresenter&gt; implements IBuyBookView  </font></div><div><font color="#797979">2. {  </font></div><div><font color="#797979">3.   </font></div><div><font color="#797979">4.     private ListView mListView;  </font></div><div><font color="#797979">5.     private BuyBookAdapter mAdapter;  </font></div><div><font color="#797979">6.   </font></div><div><font color="#797979">7.     @Override  </font></div><div><font color="#797979">8.     BuyBookPresenter initPresent()  </font></div><div><font color="#797979">9.     {  </font></div><div><font color="#797979">10.         return new BuyBookPresenter(this);  </font></div><div><font color="#797979">11.     }  </font></div><div><font color="#797979">12.   </font></div><div><font color="#797979">13.     @Override  </font></div><div><font color="#797979">14.     int getLayout()  </font></div><div><font color="#797979">15.     {  </font></div><div><font color="#797979">16.         return R.layout.activity_main;  </font></div><div><font color="#797979">17.     }  </font></div><div><font color="#797979">18.   </font></div><div><font color="#797979">19.     @Override  </font></div><div><font color="#797979">20.     void initView()  </font></div><div><font color="#797979">21.     {  </font></div><div><font color="#797979">22.         mListView = (ListView) findViewById(R.id.listview);  </font></div><div><font color="#797979">23.     }  </font></div><div><font color="#797979">24.   </font></div><div><font color="#797979">25.     @Override  </font></div><div><font color="#797979">26.     void onPrepare()  </font></div><div><font color="#797979">27.     {  </font></div><div><font color="#797979">28.         mAdapter = new BuyBookAdapter(this, basepresenter.getAdapterData());  </font></div><div><font color="#797979">29.         mListView.setAdapter(mAdapter);  </font></div><div><font color="#797979">30.         basepresenter.initData();  </font></div><div><font color="#797979">31.     }  </font></div><div><font color="#797979">32.   </font></div><div><font color="#797979">33.     @Override  </font></div><div><font color="#797979">34.     public void showToast(String msg)  </font></div><div><font color="#797979">35.     {  </font></div><div><font color="#797979">36.         Toast.makeText(this, msg, Toast.LENGTH_SHORT).show();  </font></div><div><font color="#797979">37.     }  </font></div><div><font color="#797979">38.   </font></div><div><font color="#797979">39.     @Override  </font></div><div><font color="#797979">40.     public void refreshAdapter()  </font></div><div><font color="#797979">41.     {  </font></div><div><font color="#797979">42.         mAdapter.notifyDataSetChanged();  </font></div><div><font color="#797979">43.     }  </font></div><div><font color="#797979">44.   </font></div><div><font color="#797979">45.     public void onEmpty()  </font></div><div><font color="#797979">46.     {  </font></div><div><font color="#797979">47.         mListView.setEmptyView(null);  </font></div><div><font color="#797979">48.     }  </font></div><div><font color="#797979">49. }  </font></div></div><div><font color="#797979"><br/></font></div><div><font color="#797979">最后, MVP 模式有许多好处,但是一个致命的缺点就是类太多,本来一个类最多变成了七个类,最少变成六个 ( 使用 Contract 协议类 ) .所以不是所有的页面都要用 MVP 模式的,很简单的页面就没有必要了</font></div><div><font color="#797979"><br/></font></div><div><font color="#797979"><br/></font></div><div><span style="font-weight: bold;"><font color="#797979">为什么 MVP 模式利于单元测试?</font></span></div><div><font color="#797979"><br/></font></div><div><font color="#797979">Presenter 将逻辑和 UI 分开了, 里面没有 Android 代码,都是纯正的后端代码,我们可以直接对 Present 写 Junit 测试</font></div><div><font color="#797979"><br/></font></div><div><font color="#797979"><br/></font></div><div><font color="#797979"><br/></font></div><div><font color="#797979"><br/></font></div><div><font color="#797979"><br/></font></div><div><font color="#797979"><br/></font></div><div><font color="#797979"><br/></font></div><div><font color="#797979"><br/></font></div><div><font color="#797979"><br/></font></div><div><font color="#797979"><br/></font></div><div><font color="#797979"><br/></font></div><div><font color="#797979"><br/></font></div><div><font color="#797979"><br/></font></div><div><font color="#797979"><br/></font></div><div><font color="#797979"><br/></font></div><div><font color="#797979"><br/></font></div><div><font color="#797979"><br/></font></div><div><font color="#797979"><br/></font></div><div><br/></div></span>
</div></body></html> 