上一章节我们实现了手指在屏幕上滑动的时候就能执行功能方法，但是这个方法效率是比较低的：

- 首先，A 标签的 offsetTop 的值一直是固定的，而每次执行方法都会去运算一次，我们在 data 中定义一个变量来解决这个问题：

  ```vue
  <script>
  export default {
    name: 'CityAlphabet',
    props: {
      cities: Object
    },
    computed: {
      letters () {
        const letters = []
        for (let i in this.cities) {
          letters.push(i)
        }
        return letters
      }
    },
    data () {
      return {
        touchStatus: false,
        startY: 0
      }
    },
    // 当你初次渲染 Alphabet.vue 的时候，是用一个空对象初始化的
    // 当我们通过接口获取到值的时候，Alphabet 才有值，才会被渲染
    updated () {
      this.startY = this.$refs['A'][0].offsetTop
    },
    methods: {
      handleLetterClick (e) {
        this.$emit('change', e.target.innerText)
      },
      handleTouchStart () {
        this.touchStatus = true
      },
      handleTouchMove (e) {
        if (this.touchStatus) {
          const startY = this.$refs['A'][0].offsetTop
          const touchY = e.touches[0].clientY - 79
          const index = Math.floor((touchY - this.startY) / 20)
          if (index >= 0 && index < this.letters.length) {
            this.$emit('change', this.letters[index])
          }
          console.log(index)
        }
      },
      handleTouchEnd () {
        this.touchStatus = false
      }
    }
  }
  </script>
  
  ```

- 我们做一个函数节流，当我们的鼠标在字母表上来回移动，touchmove 执行的频率是非常高的，我们可以限制一下它执行的频率

  ```vue
  <script>
  export default {
    name: 'CityAlphabet',
    props: {
      cities: Object
    },
    computed: {
      letters () {
        const letters = []
        for (let i in this.cities) {
          letters.push(i)
        }
        return letters
      }
    },
    data () {
      return {
        touchStatus: false,
        startY: 0,
        timer: null
      }
    },
    // 当你初次渲染 Alphabet.vue 的时候，是用一个空对象初始化的
    // 当我们通过接口获取到值的时候，Alphabet 才有值，才会被渲染
    updated () {
      this.startY = this.$refs['A'][0].offsetTop
    },
    methods: {
      handleLetterClick (e) {
        this.$emit('change', e.target.innerText)
      },
      handleTouchStart () {
        this.touchStatus = true
      },
      handleTouchMove (e) {
        if (this.touchStatus) {
          if (this.timer) {
            clearTimeout(this.timer)
          }
          this.timer = setTimeout(() => {
            const touchY = e.touches[0].clientY - 79
            const index = Math.floor((touchY - this.startY) / 20)
            if (index >= 0 && index < this.letters.length) {
              this.$emit('change', this.letters[index])
            }
            console.log(index)
          }, 16)
        }
      },
      handleTouchEnd () {
        this.touchStatus = false
      }
    }
  }
  </script>
  ```


## 提交线上

