# 前端如何处理十万级别的大量数据

## 前言

这是一道面试题，刚开始面试官问怎么处理大量数据，我们第一时间就想到使用分页。但是分页主要是后端角度来考虑的，从前端角度呢？我们可能会想到分批加载、懒加载、监听用户的滑动分批显示数据这些优化技术。但是如果我要对这些大量数据进行处理呢？怎么在前端操作大量数据的同时不让页面崩坏、假死呢？

这就有点伤脑经了是不是，怎么可能给前端这么多数据呢？而且数据处理一般不都是在后端处理的嘛？但是题目就是题目，我们可以通过 worker 来做子线程来实现。

## 什么是 worker

> 运行者 Worker 接口是 Web Workers API 的一部分，代表一个后台任务，它容易被创建并向创建者发回消息。创建一个运行者只要简单调用 Worker() 构造函数，指定一个脚本，在工作线程中执行。

看这概念可能有点简单无聊，通俗点就是，因为 JS 是单线程运行的，遇到一些需要处理大量数据的 JS 的时候，可能会阻塞页面的加载，造成页面的假死。这时候我们可以使用 worker， 来开辟一个独立于主线程的子线程，来运行那些大量数据的运算。这样也就不会造成主线程阻塞，从而使得页面卡死。

## worker 语法

```js
const worker = new Worker(aURL, options)
```

它有两个参数：

- **aURL（必填）**：是一个 DOMString，表示 worker 将执行的脚本 URL。必须遵循[同源策略](https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy)。
- **options（可选）**：可以用来指定 Worker 的名称，用来区分多个 Worker 线程，最好写一个。

## worker 属性

- `Worker.onerror`：指定 error 事件的监听函数。
- `Worker.onmessage`：指定 message 事件的监听函数，发送过来的数据在 `Event.data` 属性中。
- `Worker.onmessageerror`：指定 messageerror 事件的监听函数。发送的数据无法序列化为字符串时，会触发这个事件。

## worker 的方法

- `Worker.postMessage()`：向 Worker 线程发送消息。
- `Worker.terminate()`：立即终止 Worker 线程。

## 使用 worker 的注意点

### 1. 同源策略

分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。

### 2. DOM 限制

Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用 `document`、`window`、`parent` 这些对象。但是，Worker 线程可以 `navigator` 对象和 `location` 对象。

### 3. 通信联系

Worker 线程和主线程不在同一上下文环境，它们不能直接通信，必须通过消息完成。

### 4. 脚本限制

Worker 线程不能执行 `alert()` 和 `confirm()` 这两个方法，但是可以使用 `XMLHttpRequest` 对象发送 AJAX 请求。

### 5. 文件限制

Worker 线程无法读取本地文件，即不能通过 `file://` 协议打开本机的文件系统，它所加载的脚本必须来自于网络。

## 使用实例

### 没有 worker 

求斐波纳茨数列的第38项

```js
 <div style="width:100px;height:100px;background-color:red;"></div>
 document.querySelector('div').onclick=function(){
    console.log('hello world');
  }
  function fibonacci(n){
    return n<2?n:arguments.callee(n-1)+arguments.callee(n-2);
   }
console.log(fibonacci(38));
```

### 使用 worker

```js
<div style="width:100px;height:100px;background-color:red;"></div>
 
var worker=new Worker('worker.js');
worker.postMessage(40);
worker.onmessage=function(event){
    var data=event.data;
    console.log(data)
};
worker.onerror=function(event){
    console.log(event.fileName,event.lineo,event.message);
};
```

```js
<!--worker.js-->
self.onmessage = function (event) {
    var data = event.data;
    var ans = fibonacci(data);
    this.postMessage(ans);
};

function fibonacci(n) {
    return n < 2 ? n : arguments.callee(n - 1) + arguments.callee(n - 2);
}
```

## 参考文章

[MDN](https://link.juejin.im/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FWorker)

[Web Worker 是什么鬼？](https://link.juejin.im/?target=https%3A%2F%2Fwww.cnblogs.com%2Fzichi%2Fp%2F4954328.html)

[Web Worker 使用教程](https://link.juejin.im/?target=http%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2018%2F07%2Fweb-worker.html)

