# 冒泡排序（Bubble Sort）

大家学习排序算法的时候，通常最先学的都是冒泡算法，因为它是排序算法中最简单的。同时，它也是所有排序算法中时间复杂度最差的。

## 过程图解

冒泡排序只会操作相邻的两个数据，每次冒泡操作都会对相邻两个元素进行比较，看是否满足大小关系要求。不满足则进行元素互换，一次冒泡会使得至少一个元素移动到它应该在的位置。对 n 个数据的冒泡排序，需要重复 n 次。

假如我们有一组数据：`a[4, 5, 6, 3, 2, 1]`，第一次冒泡排序的过程如图：

![](https://i.loli.net/2019/03/13/5c88cc6eae735.jpg)

经过一次冒泡操作，`6` 这个最大的泡泡已经到了最顶部了，我们只需要重复 6 次冒泡操作就可以了：

![](https://i.loli.net/2019/03/13/5c88ccc80fbb2.jpg)

如图，我们看到此排序还能继续优化：当某次冒泡已经没有数据交换的时候，说明数据全部有序，停止执行冒泡操作：

![](https://i.loli.net/2019/03/13/5c88cd4e85c2d.jpg)

## 流程图与伪代码

我们根据这几张图，画一下冒泡排序大致的流程图：

![](https://i.loli.net/2019/03/13/5c88e081b8a5b.png)

然后根据上图写一下伪代码（嘛，我是先写的代码后画的图，无所谓了~）

```
a <- {'0':4,'1':5,'2':6,'3':3,'4':2,'5':1,'length':6}
轮数 i <- 0
while (i < a['length'])
  bool flag = false
  while (j < a['length']-i-1)
    if (a[j] < a[j+1])
    	j <- j+1
    else
    	t <- a[j]
      a[j] <- a[j+1]
      a[j+1] <- t
      j <- j+1
  	end
  end
  i <- i+1
  bool flag = true
end
```



## 代码实现

```js
Array.prototype.bubbleSort = function() {
  for (let i = 0; i < this.length; i++) {
    // 标志位
    let flag = false
    for (let j = 0; j < this.length - 1 - i; j++) {
      // 交换
      if (this[j] > this[j + 1]) {
        let tmp = this[j]
        this[j] = this[j + 1]
        this[j + 1] = tmp
        flag = true
      }
    }
    if (!flag) break
  }
}
```



## 一些冒泡排序的特点：

- **原地排序算法**：只涉及相邻数据的交换操作，只需要常量级别的临时空间，空间复杂度为 `O(1)`。
- **稳定的排序算法**：只有交换才能改变两个元素位置，大小相等时不做交换，相同大小数据下标顺序不变。
- **`O(n^2)` 平均时间复杂度**：最好情况 1 次冒泡，时间复杂度 `O(n)`，最坏 n 次冒泡，时间复杂度 `O(n^2)`，冒泡排序包含两个操作原子，**比较**和**交换**，每交换一次，有序度就加 1.不管算法如何改进，交换次数总是确定的，即为**逆序度**，也就是 `n*(n-1)/2 – 初始有序度`，对于 n 个数据的数组来说，平均交换次数是多少呢？最坏初识有序度是 0，最好是 `n*(n-1)/2`，不需要交换。我们平均一下取  `n*(n-1)/4`。也就是说，平均情况下需要这么多的交换操作，比较操作肯定比交换操作多，而复杂度最多就是 `O(n^2)`，所以平均情况下时间复杂度为 `O(n^2)`。

> 此算法只能算是排序算法入门的学习资料，实际上并不使用。





```
function countingSort(iArr, max) {
    var n = iArr.length;
    var oArr = [];
    // 创建长度max的数组，填充0
    var C = [];
    for(var i = 0; i <= max; i++){
        C[i] = 0;
    }
    // 遍历输入数组，填充C
    for(var j = 0; j < n; j++){
        C[iArr[j]]++;
    }
    // 遍历C，输出数组
    for(var k = 0; k <= max; k++){
        // 按顺序将值推入输出数组，并将对应标志位减1
        while(C[k]-- > 0){
            oArr.push(k);
        }
    }
    return oArr;
}
```