# 项目目录

我们现在来拆分整个项目的 src 目录：

```
.
|-- App.vue
|-- ElementUI.js
|-- api
|   |-- cacheService.js
|   `-- index.js
|-- assets
|   |-- fonts
|   |   `-- iconfont.css
|   `-- images
|       `-- avatar.jpg
|-- common
|   |-- pageDesign
|   |   |-- gridSize.vue
|   |   |-- index.js
|   |   |-- pageDesign.vue
|   |   |-- panel
|   |   |   |-- imgListWrap.vue
|   |   |   |-- imgWaterFall.vue
|   |   |   |-- shapeListWrap.vue
|   |   |   |-- stylePanel.vue
|   |   |   |-- textListWrap.vue
|   |   |   `-- widgetPanel.vue
|   |   |-- refLine.vue
|   |   |-- sizeControl.vue
|   |   |-- styleWidgets
|   |   |   |-- bgImgSelect.vue
|   |   |   |-- colorSelect.vue
|   |   |   |-- iconItemSelect.vue
|   |   |   |-- numberInput.vue
|   |   |   |-- numberSlider.vue
|   |   |   |-- settingSwitch.vue
|   |   |   |-- textInput.vue
|   |   |   |-- textInputArea.vue
|   |   |   `-- valueSelect.vue
|   |   |-- widgets
|   |   |   |-- pageStyle.vue
|   |   |   |-- wCircle
|   |   |   |   |-- wCircle.vue
|   |   |   |   `-- wCircleStyle.vue
|   |   |   |-- wGroup
|   |   |   |   |-- wGroup.vue
|   |   |   |   `-- wGroupStyle.vue
|   |   |   |-- wImage
|   |   |   |   |-- wImage.vue
|   |   |   |   `-- wImageStyle.vue
|   |   |   |-- wLine
|   |   |   |   |-- wLine.vue
|   |   |   |   `-- wLineStyle.vue
|   |   |   |-- wRectangle
|   |   |   |   |-- wRectangle.vue
|   |   |   |   `-- wRectangleStyle.vue
|   |   |   `-- wText
|   |   |       |-- wText.vue
|   |   |       `-- wTextStyle.vue
|   |   `-- zoomControl.vue
|   `-- toast
|       |-- toast.js
|       `-- toast.vue
|-- favicon.ico
|-- index.html
|-- main.js
|-- mixins
|   |-- move.js
|   `-- shortcuts.js
|-- router
|   |-- index.js
|   `-- modules
|       `-- pageDesign.js
|-- store
|   |-- index.js
|   |-- modules
|   |   `-- pageDesign.js
|   `-- mutation-types.js
|-- stylus
|   |-- base.styl
|   |-- color.styl
|   |-- element-ui.styl
|   |-- grid.styl
|   |-- main.styl
|   |-- mixin.styl
|   |-- page-design-element-ui.styl
|   `-- page-design.styl
|-- util
|   |-- clickoutside.js
|   |-- filters.js
|   `-- validator.js
`-- views
    `-- pageDesign
        `-- index.vue

```

# 单文件讲解

其中，单文件有：

- App.vue
- ElementUI.js
- favicon.ico
- index.html
- main.js



## 入口文件 main.js

这是整个项目的入口 js，它的初始化代码是：

```js
import Vue from 'vue'
import App from './App.vue'
import router from './router'
import store from './store'

Vue.config.productionTip = false

new Vue({
  router,
  store,
  render: h => h(App)
}).$mount('#app')
```

我们来一行一行的看：

```js
import Vue from 'vue'
```

第一行，很简单的 js 语法，引入 vue 模块，并设置为变量 Vue。就好像你要引入 jQuery 一样，vue 就是 `jquery-min.js`， Vue 就是 `$`。

```js
import App from './App.vue'
```

第二行，是引入的 `App.vue` 文件，在 Vue 中引入文件可以直接用 import，文件后缀名可以是 `.vue`，这是 Vue 自己的文件类型，就好像 `webpack` 会将 `js` 和 `css` 文件打包，在配置好 vue 插件后（项目默认配置），webpack 就可以将 `.vue` 类型的文件整合打包。

我们可以来接着看一下 `App.vue`，这是一个视图（或者说组件和页面），想象以下我们的 `index.html` 中什么也没有，只有一个视图，这个视图相当于一个容器，然后我们往这个容器中放各种各样的积木（其它组件或者其它页面）。

```js
import router from './router'
```

第三行，这段代码引入一段路由配置。

```js
import store from './store'
```

第四行，注入 store。

```js
Vue.config.productionTip = false
```

设置为 false 以阻止 vue 在启动的时候生成**生产提示**。

```js
new Vue({
  router,
  store,
  render: h => h(App)
}).$mount('#app')
```

使用 `new Vue` 实例化，其实就是写 `js` 时候常用的 `init`，原来是使用 `el: '#app'`，意思是将所有视图放在 id 值为 `app` 这个 DOM 元素中，现在改成了 `.$mount('#app')`，其实道理是一样的。总的来说就是将 `App.vue` 放到 `#app` 中。



## 单页面组件 App.vue

现在我们来看 `App.vue` 文件，在 Vue 中，官网叫它组件，单页面的意思是结构、样式、逻辑代码都写在同一个文件当中，引入一个组件，同时也就是引入它的结构、样式和逻辑：

```vue
<template>
  <div id="app">
    <div id="nav">
      <router-link to="/">Home</router-link> |
      <router-link to="/about">About</router-link>
    </div>
    <router-view/>
  </div>
</template>
<style lang="stylus">
#app
  font-family 'Avenir', Helvetica, Arial, sans-serif
  -webkit-font-smoothing antialiased
  -moz-osx-font-smoothing grayscale
  text-align center
  color #2c3e50

#nav
  padding 30px
  a
    font-weight bold
    color #2c3e50
    &.router-link-exact-active
      color #42b983
</style>

```

node 端之所以能识别 `.vue` 文件，是因为前面说的 `webpack` 在编译时将 `.vue` 文件中的 `html、js、css` 都抽出来合成新的单独的文件。

看这个文件内分为三大部分，分别是 `<template><script><style>`，很好理解结构、脚本、样式；`script` 就像 `node` 一样暴露一些接口，可以看到我们的 `template` 中存在两种 `router` 标签：

```html
<template>
  <div id="app">
    <div id="nav">
      <router-link to="/">Home</router-link> |
      <router-link to="/about">About</router-link>
    </div>
    <router-view/>
  </div>
</template>
```

这时候就开始涉及路由了。



## 路由

说一下路由的大致概念：传统的 PHP 路由是由服务器端根据一定的 url 规则匹配来返回给前端不同的页面代码。如以下地址：[isux.tencent.com/about](https://link.juejin.im/?target=https%3A%2F%2Fisux.tencent.com%2Fabout) 和 [isux.tencent.com/recruit](https://link.juejin.im/?target=https%3A%2F%2Fisux.tencent.com%2Frecruit)

这里注意只有 about 和 recruit，这些不带 `xxx.html` 的地址其实是服务器端经过一层封装指定到某些文件上去。同样的道理，前端也可以实现带锚点的方式实现简单的路由（不需要刷新页面）：https://zhitu.isux.us/index.php/preview/install#win64

其中 `#xxx` 就是我们的锚点路由，注意开始我们在浏览器中打开：http://localhost:8080/#/

路由可以使得我们访问诸如 `http://localhost:8080/#/about/` 和 `http://localhost:8080/#/home/` 这些页面可以不刷新跳转，直接显示，现在我们可以看到跳转的代码：

```vue
<router-link to="/">Home</router-link> |
<router-link to="/about">About</router-link>
```

还有这一句：

```vue
<router-view/>
```

这句代码在页面中放入一个路由视图容器，当我们访问 `http://localhost:8080/#/about/` 的时候会将 about 的内容放进去。如此看来，无论我们打开 `http://localhost:8080/#/home/` 还是 `http://localhost:8080/#/about/` 页面中的 `nav` 区域都是公用部分，变的只是路由容器中的内容，那么路由容器的内容税来控制？

前面的 `src/main.js` 文件中引入了这样一行代码：

```js
import router from './router'
```

现在我们打开一个 `router` 目录下的 `js` 文件：

```js
import Vue from 'vue'
import Router from 'vue-router'
import Home from './views/Home.vue'

Vue.use(Router)

export default new Router({
  mode: 'history',
  base: process.env.BASE_URL,
  routes: [
    {
      path: '/',
      name: 'home',
      component: Home
    },
    {
      path: '/about',
      name: 'about',
      // route level code-splitting
      // this generates a separate chunk (about.[hash].js) for this route
      // which is lazy-loaded when the route is visited.
      component: () => import(/* webpackChunkName: "about" */ './views/About.vue')
    }
  ]
})

```

前面引入了路由插件 `vue-router`，然后显式声明要用路由 `Vue.use(Router)`。注意到 `Home`、`About` 都是页面组件，接着注册路由器，然后开始配置路由。

路由的配置应该一目了然，给不同的 `path` 分配不同的页面组件，`name` 参数不那么重要，只是用来做识别的，看到这里就明白了，`nav` 下面的就是 `Home.vue` 的内容。到这里就可以完成路由的基本配置了。

> 我个人喜欢把页面放在 `pages` 目录下，组件放在 `components` 目录下。

## 子路由

可能有人想访问 `http://localhost:8080/#/about/me ` 的话怎么配置呢？很简单，只要给它的路由多加一个子路由配置：

```js
{
  path: '/blog',
  name: 'blog',
  component: Blog,
  children: [
    {
      path: '/',
      component: page1
    },
    {
       path: '/info',
       component: page2
    }
  ]
}
```

这时候访问 `/blog` 就会访问 `Blog` 页面，Blog 里放个路由容器就行了，然后访问 `http://localhost:8080/#/blog/`

 的时候会往路由容器中放置 `page1` 的内容，访问 `http://localhost:8080/#/blog/info` 的时候会往路由容器中放置 `page2` 的内容。

```vue
<template>
  <div id="app">
  	// 公用部分
    <div id="nav">
      <router-link to="/">Home</router-link> |
      <router-link to="/about">About</router-link>
    </div>
    // 路由容器
    <router-view/>
  </div>
</template>
```



## 路有懒加载

**首先**，可以将异步组件定义为返回一个 Promise 的工厂函数（该函数返回的 `Promise` 应该 `resolve` 组件本身）：

```js
const Foo = () => Promise.resolve({ /* 组件定义对象 */ })
```

**然后**，在 Webpack 2 中，我们可以使用动态 `import` 语法来定义代码分快点（split point）：

```js
import('./Foo.vue')// 返回 Promise
```

> **注意**：如果您使用的是 Babel，你将需要添加 syntax-dynamic-import 插件，才能使 Babel 可以正确地解析语法。

**结合这两者**，这就是如何定义一个能够被 Webpack 自动代码分割的异步组件：

```js
const Foo = () => import('./Foo.vue')
```

在路由配置中什么都不需要改变，只要像往常一样使用 `Foo`：

```js
const router = new VueRouter({
  routes: [
    { path: '/foo', component: Foo }
  ]
})
```

### Vue-Cli3 中对路由懒加载的实现

```js
{
  path: '/about',
  name: 'about',
  // route level code-splitting
  // this generates a separate chunk (about.[hash].js) for this route
  // which is lazy-loaded when the route is visited.
  component: () => import(/* webpackChunkName: "about" */ './views/About.vue')
}
```

这样子加载的路由组件就是**惰性加载**的组件，这种调用组件的方式根据路由等级来分割代码（`code-splitting`），它会为当前路由生成一个单独的块文件比如：`about.[hash].js` 这样的文件，同时还会生成同样的 `css` 文件，生成的文件名是由这句代码控制的：

```js
/* webpackChunkName: "about" */
```

双引号中的 `about` 就是生成的文件的主名称，如果不加这段注释文字就会以数字（0 开始）为文件名称。



## 小结 1

通过刚才的学习，我们了解到了从初始化到页面展示，Vue 的页面架构流程大概是这样的：

![](https://mc.qcloudimg.com/static/img/d63005a5d785358289fab9f0ea997aff/image.png)

总结一下内容：

1. 搭建环境
2. 代码逻辑
3. 单页面组件
4. 路由
5. 子路由
6. 懒加载



> 上面我们初步了解了单页面组件这个概念，现在通过一个项目，来进一步解析组件的应用。



## 需求背景

开发一个组件库：

![](https://blog-10039692.file.myqcloud.com/1490871464533_919_1490871464762.png)

这是我们组件库的首页，包含三个子页面，点击会通过路由跳转到相应的页面组件。

配置路由：

```js
import Vue from 'vue'
import Router from 'vue-router'
// 引用页面模板->供路由使用
import index from '../pages/index.vue'
import pageQuiButton from '../pages/pageQuiButton.vue'
import pageQuiList from '../pages/pageQuiList.vue'
import pageQuiNav from '../pages/pageQuiNav.vue'

Vue.use(Router)

export default new Router({
  routes: [
    {
      path: '/',
      name: 'index',
      component: index
    },
    {
      path: '/btn',
      name: 'btn',
      component: pageQuiButton
    },
    {
      path: '/list',
      name: 'list',
      component: pageQuiList
    },
    {
      path: '/nav',
      name: 'nav',
      component: pageQuiNav
    }
  ]
})
```

很好看出，具体的每页内容由各个组件文件负责，我们来回顾一下入口页面 `App.vue`，这个文件承载着一些公共元素，还有就是一个路由容器，我们的首页 `index.vue` 到时候也是挂载在路由容器中的，看看 `App.vue` 代码：

```vue
<template>
  <div id="app">
    <div id="nav">
      <router-link to="/">Home</router-link> |
      <router-link to="/about">About</router-link>
    </div>
    <router-view/>
  </div>
</template>
<style lang="stylus">
#app
  font-family 'Avenir', Helvetica, Arial, sans-serif
  -webkit-font-smoothing antialiased
  -moz-osx-font-smoothing grayscale
  text-align center
  color #2c3e50

#nav
  padding 30px
  a
    font-weight bold
    color #2c3e50
    &.router-link-exact-active
      color #42b983
</style>

```

简单分析一下，`<div id="nav"></div>` 是一个公用的块，也就是每个子页面都会带着这个 `<div>` ，它的作用就是方便我们们快速地切换各个页面组件，子页面的内容会注入到 `router-view` 容器当中。这里值得关注的是 `style` 标签，我们可以在 `style` 标签里面直接写样式，也可以直接引入一个样式文件，可以添加`scoped` ，此关键字表示这个样式是私有的，也就是说，即使两个组件写着一样的 `#appP{}` 样式也不会有冲突，程序会自动加上识别标志，从而使得 `style` 样式互相隔离，你也可以自定义标志名称，这也是 `script` 标签中有个 `name` 参数。



## 首页

```vue
<template>
  <div class="mod-module mod-parallel">
    <div class="img-list type-full">
      <div class="img-box">
        <p class="img-item">
          <a class="page-link" href="#/btn">按钮</a>
        </p>
      </div>
      <div class="img-box">
        <p class="img-item">
          <a class="page-link" href="#/list">列表</a>
        </p>
      </div>
      <div class="img-box">
        <p class="img-item">
          <a class="page-link" href="#/nav">导航</a>
        </p>
      </div>
    </div>
  </div>
</template>

<style scoped>
 @import './css/index.css';
</style>
```

我们可以看到首页代码是十分简单的，也就是集合导航链接，程序运行的时候，会将 `<template>` 标签里面的内容都注入到 `App.vue` 页面中的 `router-view` 标签中，从而实现无刷新的路由跳转。

> 下面的例子当中，我们先不急看其它几个子页面，我们先来看单独的组件。



## 按钮组件

```vue
<template>
  <button class="qui-btn">
    <span>{{msg}}</span>
  </button>
</template>

<script>
  export default {
        data:function(){
            return {
                msg:'下载'
            }
        }
  }
</script>
<style scoped>
  @import './css/reset.import.css';
  @import './css/qui-btn.import.css';
</style>
```

很简单，就是一个正常的 `button` 标签，`script` 标签中暴露这个组件的 `data` 属性（`data` 是 `Vue` 的属性）。当按钮组件被初始化的时候，`msg` 自定义属性会被绑定到 `<span>` 标案中的 `{{ msg }}` 。

> 如果不是组件的话，正常 `data` 写法可以直接写一个对象，比如 `data: { msg: '下载' }`，但是由于组件是会在多个地方引用的，JS 中直接共享对象会造成引用传递，也就是说修改了 `msg` 后所有按钮的 `msg` 都会跟着修改，所以这里用 `function` 来每次返回一个对象实例。

这时候问题来了，按钮中的文案我希望可以异化，不能每次都初始化一个叫做 “下载” 文案的按钮吧，我们希望可以以属性的方式使用，比如这样子：

```html
<qui-btn msg="确定" class="small"></qui-btn>
```

 没问题，属性的接口暴露只需要写在 `props` 里面就可以了，如下所示修改下 `script` 标签的内容：

```js
<script>
  export default {
    props: {
      msg: {
        default: '下载'
      }
    }
  }
</script>
```

我们在上一章开头就讲了 Vue 是数据驱动的，当我们在 `btn` 写上 `msg="确认"` 的时候，对应 `script` 里面的 `msg` 的属性就会自动修改了。



## 按钮事件

按钮总少不了点击事件吧，那在 Vue 中怎么绑定事件呢，用 `methods` 属性，看下代码：

```javascript
<template>
  <button class="qui-btn" v-on:click="btnClickEvent">
    <span>{{msg}}</span>
  </button>
</template>

<script>
  export default {
    props: {
      msg: {
        default: '下载'
      }
    },
    methods: {    //绑定事件的关键代码
      btnClickEvent: function(){
        alert(this.msg);
      }
    }
  }
</script>
```

`methods` 属性中可以写任何的自定义函数，写完之后绑定的方式也很简单，在 `button` 上写关键字 `v-on:click`，把对应的事件写上就可以了，以上代码实现的就是点击按钮弹出按钮中的文案，`v-XXX` 是 Vue 里的一些关键字，叫做指令，我们后面会慢慢学到更多的指令；`v-on:click` 可以缩写为 `@click`，当然还有其他的事件比如 `v-on:tab` 等等；



## 使用按钮组件 pageQuiButton.vue

现在我们大致做了一个按钮组件了，那么怎么调用它呢，去到我们的 pageQuiButton 子页面。

```vue
// pageQuiButton.vue
<template>
  <div id="pageQuiButton">
    <!--使用-->
    <qui-btn msg="确定" class="small"></qui-btn>
  </div>
</template>
<script>
  import quiBtn from '../components/quiButton.vue' /*引用*/
  export default {
    name: 'pageQuiButton',
    components: {
      'qui-btn': quiBtn /*注册自定义标签*/
    }
  }
</script>

```

我们在这个子页面中引用这个按钮组件。从 `script` 开始解析，首先引入我们的组件赋值给变量 `quiBtn`，使用时候直接将 `quiBtn` 作为对象的一部分写进 `components 属性` ，这是 Vue 用来存储引用组件的关键字，同时对应我们自定义的标签 `"qui-btn"` ，完成这些操作之后，我们就可以在页面中看到具体的效果，点击按钮跳出对应的文案。

上述我们将按钮事件写成默认的 `alert(thi.msg)`，如果有些按钮想要异化怎么办。之前说了 `msg` 属性可以支持自定义，那么按钮的点击事件如何支持自定义呢？

```html
// pageQuiButton.vue
// 监听子组件的事件
<qui-btn v-on:btnClickEvent="doStn" msg="我可以点击"></qui-btn>
```

上面代码在引用组件的时候，注册了一个事件 `btnClickEvent`，这是之前我们在按钮组件中绑定到按钮的 `click` 事件中的，然后我们给这个事件一个自定义的方法 `doStn`，同时，在 `script` 中声明这个自定义的方法如下：

```js
// pageQuiButton.vue
// 页面中引用子组件并监听子组件的事件
<script>
	import quiBtn from '../component/quiButton.vue'
	
	export default {
    name: 'pageQuiButton',
    components: {
      'qui-btn': quiBtn
    },
    methods: {
      doSth: function () {
        alert('你点击了组件的 btnClickEvent')
      }
    }
	}
</script>
```

专业一点的说法是，这叫做监听，由引入方（暂且叫做父组件）监听子组件的内置方法；同时在子组件中，需要触发这个事件，以下是在子组件中的关键代码：

```js
// quiButton.vue
// 子组件中的代码
<script>
  export default {
    props: {
      msg: {
        default: '下载'
      }
    },
    methods: {
      btnClickEvent: function(){
        alert("先弹出默认的文案");
        this.$emit('btnClickEvent');//关键代码父组件触发自定义事件
      }
    }
  }
</script>
```

这里的关键代码就是 `$emit`，也就是触发机制，父组件监听，子组件触发。我们这样子理解：儿子新注册了一个电话号码，儿子把电话号码告诉老爸，让老爸打电话给他，于是他老爸就拨打了儿子的电话（监听），然后必须是儿子接听了电话（触发），两人之间才算完成了打电话这件事。

完成这步以后，老爸（父组件）就可以给不同子组件调用不同的事件处理了（不同的电话号码）：

```vue
<qui-btn v-on:btnClickEvent="doSth1" msg="确定" ></qui-btn>
<qui-btn v-on:btnClickEvent="doSth2" msg="取消" ></qui-btn>
<script>
/*这里只是简单展示*/
    methods: {
      doSth1: function(){
        alert('111');
      },
      doSth2: function(){
        alert('222');
      }
    }
</script>
```



## 按钮加图标

有时候单纯的文案异化还不够，比如一些按钮是图标 + 文字类型的，而且图标还可能不一样，那应该怎么办？

![](https://blog-10039692.file.myqcloud.com/1490873116729_7495_1490873116848.png)

如果按钮组件的结构除了开发时候预设的 DOM 结构之外，允许我们在调用的时候添加一些自己想要的结构，是不是更好呢？Vue 为此给我们预设了 `slot` 标签：

```vue
// quiButton.vue
<template>
  <button class="qui-btn" v-on:click="btnClickEvent">
    <slot name="icon"></slot><!--重点在这里-->
    <span>{{msg}}</span>
  </button>
</template>
```

加入了关键字 `slot` 并赋予一个 `name` 值之后，我们再看看引用如何使用

```vue
// pageQuiButton.vue
<qui-btn msg="下载" class="with-icon">
  <img slot="icon" class="ico" src="xxx.png" />
</qui-btn>
```

`img` 上有个关键字 `slot="icon"` 对应组件中的 `name="icon"`，渲染的时候，会将 `img` 整个替换掉组件中对应 `name` 的 `<slot>` 标签，其实很好理解，`slot` 就是插槽的意思，相当于把 `img` 这块的内容插入到名叫 `icon` 的插槽中去。



学到这里，我们已经学会了使用 `props` 给按钮自定义文案，用 `on` 和 `emit` 给按钮自定义点击触发，用 `slot` 给按钮添加一些自定义结构。**当你回头翻文档的时候，你会发现 props、事件、slot 这三样刚好就是学习组件通讯中最最最最关键的三个环节。将这三个环节以实际案例解析出来之后，好像也没那么困难。**

上述我们已经讨论了如何制作一个按钮组件，以及如何使用我们的按钮组件

![](https://blog-10039692.file.myqcloud.com/1490873224108_8909_1490873224225.png)

接下来我们通过制作一个导航组件，来了解一下 Vue 中对于 `for` 循环的巧妙使用。



## 导航组件 quiNav.vue

我们将完成这样一个操作，点击导航中的 `tab`，可以给当前的 `tab` 加上一个 `active` 类，同时切换底部的黄色滑条，并且输出当前 `tab` 的文案，同时支持自定义事件。

由于在现实项目中，我们导航 `tab` 个数是不定的，所以制作组件的时候，我们希望可以暴露一个属性来支持导航的 `tab` 个数，而 `tab` 的长相和应用其实是一样的，那么这时候我们可以使用一个 `for` 循环来输出每一个 `tab`。先来看看关键代码：

```vue
// quiNav.vue
<tempalte>
	<div class="qui-nav nav-type-1">\
		<!-- 关键代码 v-for -->
		<a v-for="(item, index) in items">
		  <span class="nav-txt">{{ item.text }}</span>
		</a>
  </div>
</template>

<script>
	export default {
    data: funtion () {
      return {
        items: [
          {
            text: '首页',
            active: true
          },
          {
            text: '列表',
            active: false
          },
          {
            text: '关于',
            active: false
          }
        ]
      }
    }
	}
<script>
  
```

改代码关键在于 `v-for` 关键字（还记得之前说过的 `v-on` 绑定事件嘛，`v-xxx` 关键字是 Vue 预留的）可以把它理解为 `js` 中的 `for in` 循环，`items` 是我们在 `data` 中定义好的数据对象（还记得为什么 `data` 要写在 `function` 中返回嘛，因为不使用 `return` 会使得包裹的数据在项目的全局可见，会造成变量污染）。`v-for="(item, index) in items"` 暴露 `item` 和 `index` 两个接口，这是 Vue 提供的，代表 `items` 中的每一项以及其对应的下标，接着我们就可以在标签中使用绑定 `{{ item.text }}` 了。

> 如果没有 return，如果 Vue 没有这条规则，点击一个按钮就可能会影响到*其它所有。

这段代码理解了之后，我们再延伸一个动态添加 `class` 的概念，我们希望每个 `tab` 都有默认的 `class` 类名（比如 `nav-item` 类），在点击每个 `tab` 的时候，当前 `tab` 添加 `active` 类，其他的 `tab` 删除这个 `active` 类，在 Vue 怎么实现呢？



## 动态类名

```vue
//quiNav.vue
<template>
  <div class="qui-nav nav-type-1">
    <a
      v-for="(item, index) in items"
      :class="[commonClass,item.active ? activeClass : '']"
    >
      <span class="nav-txt">{{item.text}}</span>
    </a>
  </div>
</template>

<script>
  export default {
    data:function(){
      return {
        commonClass:'nav-item',
        activeClass:'active',
        items:[
            ...//数据
        ]
      }
    }
  }
</script>
```

在 `template` 中添加一句关键代码：

```js
:class="[commonClass,item.active ? activeClass : '']"
```

`:class` 给组件绑定一个 `class` 属性（类似 JQ 中的 `attr` 方法），`:class="xxx"` 和 `class="xxx"` 的区别在于不带冒号的是静态的字符串绑定，带冒号的是动态的变量绑定，不带冒号的则是静态。

我们给 `class` 绑定了一个数组，这个数组带有变量，先看 `commonClass`，这个变量在 `data` 中定义了，然后数组的第二个元素是一个 `JS` 的三元运算符 `item.active?activeClass:''`，当每个 `item` 中的 `active` 值为 `true` 的时候，绑定 `activeClass` 变量对应的类，如果为 `false`，则为空。最后的结果是当 `item.active` 为 `true` 的时候，`tab` 的 `class` 值为 `nav-item active`，当为 `false`，就只有 `nav-item`。

上面的代码很好理解，我们切换 `tab` 的时候同时添加 `active 类`。（再次体现数据驱动）

那么问题来了，怎么去修改每个 `item` 的 `active` 值呢？没错，给每个 `tab` 绑定一个点击事件，当点击事件触发的时候，修改当前 `tab` 对应 `item` 的 `active` 值。于是：

```vue
<template>
  <div class="qui-nav nav-type-1">
    <a
       v-for="(item, index) in items"
       :class="[commonClass,item.active ? activeClass : '']"
       v-on:click="navClickEvent(items,index)"
    >
      <span class="nav-txt">{{item.text}}</span>
    </a>
  </div>
</template>

<script>
  export default {
    data:function(){
      return {
        commonClass:'nav-item',
        activeClass:'active',
        items:[
          {
            text: '首页',
            active : true
          },
          ......
        ]
      }
    },
    methods:{
      navClickEvent:function(items,index){
        /*默认切换类的动作*/
        items.forEach(function(el){
          el.active = false;
        });
        items[index].active = true;
        /*开放用户自定义的接口*/
        /*可以让父组件使用其中的 items 和 index*/
        this.$emit('navClickEvent',items,index);
      }
    }
  }
</script>
```

我们使用 `forEach` 给每个 `a` 标签绑定了一个 `click` 事件，对应 `methods` 中定义的 `navClickEvent` ，接受两个参数 `items` 和 `index`（你也可以传入 item 和 index，看个人喜好咯），然后当点击的时候，最后触发一次自定义事件



## 小结

1. 页面路由的配置
2. 按钮组件自定义属性props
3. 按钮组件自定义事件 $on $emit
4. 按钮组件自定义子块slot
5. for循环实现导航组件
6. 动态类名



> 上述内容已经基本上涵盖了组件的重要知识点，主要是父组件（页面）和子组件之间的调用和通讯（数据交互绑定），好好消耗一下我们会发现，其实Vue的总体逻辑思想和jQuery是一样的，毕竟最后都回归到javascript，只是由于代码设计角度的不同，我们可能看到和以前调用jQuery时候的写法不一致，但其实都有对方的影子在里面，相信理解了Vue的代码思想之后，以后我们学习React等其他类似的框架的时候，也会比较得心应手了。



## 列表组件 quiList.vue

本节我们主要要完成这样一个列表功能，每一行的列表是一个组件，列表内可能出现按钮组件或者箭头组件，点击按钮组件可以自定义事件，同时可以根据不同的参数来决定当前列表是带按钮的列表 or 带箭头的列表。

我们先来看一下这个组件文件：

```vue
//quiList.vue
<template>
  <div class="qui-list">
    <span class="list-tips">{{tipsText}}</span>
    <qui-btn v-on:btnClickEvent="btnClickEvent" :msg=msg class="small"></qui-btn>
  </div>
</template>

<script>
  import quiButton from '../components/quiButton.vue'
  export default{
    props:{
      msg: {
        default: '下载'
      },
      tipsText: {
        default: '默认的文案'
      }
    },
    components: {
      'qui-btn': quiButton
    }，
    methods:{
      btnClickEvent:function(){
          alert('按钮点击事件')
      }
    }
  }
</script>
```

上面的知识点基本上就是我们之前学过的，只不过记住 `quiList` 本身是一个组件，而在这个组件里面，我们又引入了按钮组件 `quiButton`，也就是组件内引用组件，实际上就是组件的嵌套，注意到这里 `:msg=msg` 的使用，这里冒号表示绑定的是一个变量 `msg` ，然后这个属性通过 `props` 暴露出去（本身在按钮中就暴露了 `msg` 给列表组件使用）：

![](https://blog-10039692.file.myqcloud.com/1490929888497_8898_1490929888715.png)

至于点击事件，我们之前学习过的事件绑定。现在引入一个新的问题，**是否有一个参数，可以决定列表组件的右侧是放置按钮组件呢？还是箭头组件**



## 动态组件

Vue 中提供了一些特定关键字，`is` 和特定的结构 `<component>` 来生成动态组件，让我们修改下：

```vue
<script>
  import quiButton from '../components/quiButton.vue'
  import quiArrow from '../components/quiArrow.vue'
  export default{
    props:{
      msg: {
        default: '下载'
      },
      tipsText: {
        default: '默认的文案'
      },
      currentView:{
        default: 'qui-btn'
      }
    },
    components: {
      'qui-btn': quiButton,
      'qui-arrow': quiArrow
    },
    methods: {
      clickEvent: function () {

      }
    }
  }
</script>
```

首先我们先 `import` 一个箭头组件，在 `components` 中添加一个自定义标签的 `qui-arrow`，注意到我们多了一个 `currentView` 的自定义属性，默认值是 `qui-btn`，现在再看看 `template` 标签中写什么：

```vue
<template>
  <div class="qui-list">
    <span class="list-tips">{{tipsText}}</span>
    <component
    	:is="currentView"
    	v-on:btnClickEvent="clickEvent"
    	:msg=msg
      class="small" 
    	keep-alive
    ></component>
  </div>
</template>

```

我们将 `qui-btn` 去掉了，取而代之的是一个 `component` 标签，这是 `Vue` 自带的一个标签，可以把它当作一个容器，这个容器可以用来装按钮，也可以用来装箭头。决定这个容器装的是什么的关键代码是 `is="currentView"`，当 `currentView` 的值为 `qui-btn` 的时候，就是按钮，反之就是箭头组件。而我们设置的默认值是 `qui-btn`。

`keep-alive` 关键字保持这个组件在内存中是常驻的，由于动态组件可能需要动态切换，这样保持组件活跃可以减少组件变化的时候的内存消耗。

可以看到我们的 `component` 上还保留着按钮的点击事件和 `msg` 信息，这些没有关系，只要箭头组件中不出现同样的变量就不会发生冲突。

```html
<qui-list tipsText="自定义文案，默认右边是按钮" msg="弹层"></qui-list>
<qui-list v-on:btnClickEvent="test"></qui-list>
<qui-list ref="child1" tipsText="最右边是箭头" currentView="qui-arrow"></qui-list>
```

使用列表组件的时候，只需要给暴露出来的 `currentView` 制指定一个值，就可以决定右侧是按钮还是箭头了。注意最后一个 `qui-list` 上有一个 `ref` 的属性，这个属性代表了组件集合，当页面中有很多组件的时候，可以通过几种方法来获取对应的某个组件的信息：

```js
console.log(this.$children[0].msg);//通过数组获取
console.log(this.$refs.child1.msg);//通过对象集合获取
```

其实关于动态组件，不一定要用 `is + component` 来实现，在 Vue 中有一个指令叫做 `v-if / v-else / v-else-if`，统称判断指令，配合展示指令 `v-show`，可以根据指定的值来决定对应的组件是否应该展示，另外这种做法我就不展示了。

## 生命周期

这里简单讲一下什么是组件的生命周期，上面我们通过refs来获取组件对象的信息，那么在什么时候或者说哪个时机点去做这件事呢，组件从引用到调用到销毁（比较少操作）有以下几个关键回调函数：

```js
<script>
  export default {
    components: {
      'qui-list': quiList
    },
    beforeCreate:function(){},//组件实例化之前
    created:function(){},//组件实例化了
    beforeMount:function(){},//组件写入dom结构之前
    mounted:function(){//组件写入dom结构了
      console.log(this.$children);
      console.log(this.$refs);
    },
    beforeUpdate:function(){},//组件更新前
    updated:function(){},//组件更新比如修改了文案
    beforeDestroy:function(){},//组件销毁之前
    destroyed:function(){}//组件已经销毁
  }
</script>
```

所以要想使用refs的内容，就需要在组件写入dom之后才能开始调用哦！

## 我还需要学什么

目前为止，我们三篇文章已经学了大部分的关于组件和路由的知识，当然这并不是Vue的全部，只是相对于其他的知识点，这些可以算是一个垫脚石，看懂了这些，对后面其他API的应用，帮助很大。下面我列举一些其他的，后续大家可以去官网查看资料的一些关键点，其实都不难，只要有一些小小的项目demo实践，你会发现Vue也不过如此。

### 过渡

过渡其实就是CSS3动画，transition这些，只是写CSS3变成好像在写JS一样，有点类似于greenSock的一些思想。

### 指令

目前为止我们学习了一些常用指令，像v-on，v-bind，v-for，还有几个常用的像刚才提到的判断指令和v-show指令，还有v-model指令（主要用于input等表单组件）。当知道指令作用的时候，学习起来其实并不难。

### Render

渲染这个方法是我觉得应该用心去学习的，它可以方便我们写出更好的面向对象的组件，而学习它的成本在于这个接口更接近于原生JS代码的使用。如果有需要，后续也可以写一篇关于Render的文章。

## 总结

三篇系列文暂时在这里告一段落，有些童靴可能到这里还是觉得没有学会Vue，对不起，可能是我的标题太夸张了，也可能因为我的例子还不够清晰，文笔也还不好理解。不过没关系，回顾我们的学习历程，你可以按照这个知识点的学习过程，去找更多的文章，毕竟“熟读唐诗三百首，不会作诗也会吟”嘛。当然，学习过程中我们自己更多的练习和尝试才能锻炼巩固知识。至于浅入之后是浅出还是深出，还是要靠大家自己去定义了！

文末附上所有相关代码和官方文档地址~~~























我们已经了解了 Vue 环境的搭建以及两个重要思想——路由和组件的学习，通过组件库中的按钮组件和导航组件，相信大家也开始了解相应的知识点，接下来详细分析如何使用多个组件组成一个复用组件。

















我们能看到最后几行的组件展示：

```js
new Vue({
  router,
  store,
  render: h => h(App)
}).$mount('#app')
```

```js
render: h => h(App)
```

这个是 es6 的语法，表示 Vue 实例选项对象的 `render` 方法作为一个函数，接受传入的参数 `h` 函数，返回 `h(App)` 的函数调用结果。其次，Vue 在创建 Vue 实例时，通过调用 render 方法来渲染实例的 DOM 树。最后，Vue 在调用 render 方法时，会传入一个 `createElement` 函数作为参数，也就是这里的 `h` 的实参是 `createElement` 函数，然后 `createElement` 会以 APP 为参数进行调用，关于 `createElement` 函数的参数说明参见：[Element-Arguments](http://vuejs.org/v2/guide/render-function.html#createElement-Arguments)。

