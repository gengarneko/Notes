<html>
<head>
  <title>3.05 -- Redux 3 - 纯函数 (Pure Function) 简介</title>
  <basefont face="Consolas" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600363 (zh-CN, DDL); Windows/6.1.1 (Win64);"/>
  <style>
    body, td {
      font-family: Consolas;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="2033"/>
<h1>3.05 -- Redux 3 - 纯函数 (Pure Function) 简介</h1>

<div>
<span><div><div>我们接下来会继续优化我们的 createStore 的模式, 让它使我们的应用程序获得更好的性能.</div><div><br/></div><div>但在开始之前, 我们先来学习一下函数式编程里面非常重要的概念 -- 纯函数 (Pure Function).</div><div><br/></div><div>简单来说, 一个函数的返回结果只依赖于它的参数, 并且在执行过程里面没有副作用, 我们就把这个函数叫做纯函数. 这么说肯定比较抽象, 我们把它掰开来:</div><ol><li><div>函数的返回结果只依赖于它的参数.</div></li><li><div>函数执行过程里面没有副作用.</div></li></ol><div><br/></div><div>函数的返回结果只依赖于它的参数</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">const a = 1</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">const foo = (b) =&gt; a + b</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">foo(2) // =&gt; 3</span></div></div><div><br/></div><div>foo 函数不是一个纯函数, 因为它返回的结果依赖于外部变量 a, 我们在不知道 a 的值得情况下, 并不能保证 foo(2) 的返回值是 3. 虽然 foo 函数的代码实现并没有变化, 传入的参数也没有变化, 但它的返回值却是不可预料的, 现在 foo(2) 是 3, 可能过了一会就是 4 了, 因为 a 可能发生了变化变成了 2.</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">const a = 1</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">const foo = (x, b) =&gt; x + b</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">foo(1, 2) // =&gt; 3</span></div></div><div><br/></div><div>现在 foo 返回的结果只依赖于它的参数, 不管你外部发生什么变化.</div><div><br/></div><div>这就是纯函数的第一个条件: 一个函数的返回结果只依赖于它的参数.</div><div><br/></div><div>函数执行过程没有副作用</div><div><br/></div><div>一个函数执行过程对产生了外部可观察的变化那么就说这个函数是有副作用的.</div><div><br/></div><div>我们修改一下 foo:</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">const a = 1</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">const foo = (obj, b) =&gt; {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  return obj.x + b</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">const counter = { x: 1 }</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">foo(counter, 2) // =&gt; 3</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">counter.x // =&gt; 1</span></div></div><div><br/></div><div>我们把原来的 x 换成了 obj, 我们现在可以往里面传一个对象进行计算, 计算的过程里面并不会对传入的对象进行修改, 计算前后的 counter 不会发生任何变化, 计算前是 1, 计算后也是 1, 它现在是纯的. 但是再稍微修改一下:</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">const a = 1</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">const foo = (obj, b) =&gt; {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  obj.x = 2</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  return obj.x + b</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">const counter = { x: 1 }</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">foo(counter, 2) // =&gt; 4</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">counter.x // =&gt; 2</span></div></div><div><br/></div><div>现在情况发生了变化, foo 函数的执行对外部的 counter 产生了影响, 它产生了副作用, 因为它修改了外部传进来的对象, 它是不纯的.</div><div><br/></div><div>但是你在函数内部构建的变量, 然后进行数据的修改不是副作用:</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">const foo = (b) =&gt; {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  const obj = { x: 1 }</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  obj.x = 2</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  return obj.x + b</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div></div><div><br/></div><div>虽然 foo 函数内部修改了 obj, 但是 obj 是内部变量, 外部程序根本观察不到, 修改 obj 并不会产生外部可观察的变化, 这个函数是没有副作用的, 因此它是一个纯函数.</div><div><br/></div><div>除了修改外部的变量, 一个函数在执行过程中还有很多方式产生外部可观察的变化, 比如说调用 DOM API 修改页面, 或者你发送了 AJAX 请求, 还有调用 window.reload 刷新浏览器, 甚至是 console.log 往控制台打印数据也是副作用.</div><div><br/></div><div>纯函数很严格, 也就是说你几乎除了计算数据以外什么都不能干, 计算的时候还不能依赖除了函数参数以外的数据.</div><div><br/></div><div>总结</div><div><br/></div><div>一个函数的返回结果只依赖于它的参数, 并且在执行过程中里面没有副作用, 我们就把这个函数叫做纯函数.</div><div><br/></div><div>为什么要煞费苦心地构建纯函数&gt; 因为纯函数非常靠谱, 不会产生意料之外的行为, 程序测试非常方便.</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></div></span>
</div></body></html> 