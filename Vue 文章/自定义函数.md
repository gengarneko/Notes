# 使用 Vue 优雅地实现点击元素外触发事件

> 最近在做一个海报编辑器，经常会遇到这样一个场景：点击一块区域，弹出相应的编辑区；继续点击别的区域，此编辑区域隐藏。于是查找资料发现可以使用 Vue 的自定义指令，来实现这个运用广泛的公共工具方法。



## 1 - Vue 自定义指令

### 1.1 官方定义

首先我们得从官方文档中了解什么是自定义函数：

- [自定义指令](https://cn.vuejs.org/v2/guide/custom-directive.html)
- [Vue.directive](https://cn.vuejs.org/v2/api/#Vue-directive)

> 除了核心功能内置的诸如 `v-model` 和 `v-show` 指令，Vue 还支持注册自定义指令。Vue 2.0 中，代码复用和抽象的主要形式是组件，但是有些情况下仍然需要对普通 DOM 元素进行底层操作。

### 1.2 示例

官方使用了一个 `当页面加载时，输入框自动聚焦` 的应用场景示例。当我们打开一个页面，只要没有点击过任何内容，这个输入框就应该处于聚焦状态，分为两种实现：

- 全局指令

  ```js
  // 注册一个全局自定义指令 `v-focus`
  Vue.directive('focus', {
    // 当被绑定的元素插入到 DOM 中时……
    inserted: function (el) {
      // 聚焦元素
      el.focus()
    }
  })
  ```

- 局部指令

  ```js
  directives: {
    focus: {
      // 指令的定义
      inserted: function (el) {
        el.focus()
      }
    }
  }
  ```

通过以上两种方式注册完之后就可以在模板中任何元素上使用自定义的 `v-focus` 属性：

```html
<input v-focus>
```

### 1.3 钩子函数

一个对象可以提供如下几个**可选的**钩子函数：

- `bind`：只调用一次，指令第一次绑定到元素时调用。运用在只进行一次性的初始化设置场景。
- `inserted`：被绑定元素插入父节点时调用（仅保证父节点存在，但不一定被插入到文档中）。
- `update`：所在组件的 VNode 更新时调用，**但是可能发生在其子 VNode 更新之前**。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新。
- `componentUpdate`：指令所在组件的 VNode 及其子 VNode 全部更新后调用。
- `unbind`：只调用一次，指令与元素解绑时调用。

### 1.4 钩子函数参数

指令钩子函数会被传入以下参数：

- `el`：指令所绑定的元素，可以用来直接操作 DOM。
- `binding`：一个对象，包含以下属性：
  - `name`：指令名，不包括 `v-` 前缀。
  - `value`：指令的绑定值，例如 `v-my-directive="1 + 1"`，值为 2.
  - `oldValue`：指令绑定的前一个值，仅在 `update` 和 `componentUpdate` 钩子中可用，无论值是否改变都可用。
  - `expression`：字符串形式的指令表达式。例如 `v-my-directive="1 + 1"` 中，表达式为 `"1 + 1"`。
  - `arg`：传给指令的参数，可选。例如 `v-my-directive:foo`中，参数为 `"foo"`。
  - `modifiers`：一个包含修饰符的对象。例如：`v-my-directive.foo.bar` 中，修饰符对象为 `{ foo: true, bar: true }`。
- `vnode`：Vue 编译生成的虚拟节点。
- `oldVnode`：上一个虚拟节点，仅在 `update` 和 `componentUpdated` 钩子中可用。

示例：

```html
<div id="hook-arguments-example" v-demo:foo.a.b="message"></div>
```

```js
Vue.directive('demo', {
  bind: function (el, binding, vnode) {
    var s = JSON.stringify
    el.innerHTML =
      'name: '       + s(binding.name) + '<br>' +
      'value: '      + s(binding.value) + '<br>' +
      'expression: ' + s(binding.expression) + '<br>' +
      'argument: '   + s(binding.arg) + '<br>' +
      'modifiers: '  + s(binding.modifiers) + '<br>' +
      'vnode keys: ' + Object.keys(vnode).join(', ')
  }
})

new Vue({
  el: '#hook-arguments-example',
  data: {
    message: 'hello!'
  }
})
```

![](https://i.loli.net/2019/03/03/5c7b3c785a292.png)

### 1.5 函数简写

在很多时候，你可能想在 `bind` 和 `update` 时触发相同行为，而不关心其它的钩子。比如这样写:

```js
Vue.directive('color-swatch', function (el, binding) {
  el.style.backgroundColor = binding.value
})
```

### 1.6 对象字面量

如果指令需要多个值，可以传入一个 JavaScript 对象字面量。记住，指令函数能够接受所有合法的 JavaScript 表达式。

```html
<div v-demo="{ color: 'white', text: 'hello!' }"></div>
```

```js
Vue.directive('demo', function (el, binding) {
  console.log(binding.value.color) // => "white"
  console.log(binding.value.text)  // => "hello!"
})
```



## 2 - 思路

给 document 绑定一个 click 事件，然后判断触发点击事件的元素是不是当前显示区域所绑定的点击区域，如果不是，就触发点击隐藏事件：

```js
$(document).mouseup(function(e){
  var _con = $(' 目标区域 ');   // 设置目标区域
  if(!_con.is(e.target)){ // 判断是不是目标区域
    some code...   // 功能代码
  }
});
```



## 3 - 实现

clikcoutside.js

```js
export default {
  /**
   * 绑定方法
   * @param {Object} el - The element the directive is bound to.
   * @param {Object} binding - An vue directive object
   */
  bind(el, binding) {
    const documentHandler = (e) => {
      if (el.contains(e.target)) return

      binding.value(e)
    }
    el.__vueClickOutside__ = documentHandler
    document.addEventListener('click', documentHandler)
  },
  /**
   * 更新方法
   */
  update() {

  },
  /**
   * 销毁方法
   * @param {Object} el - The element the directive is bound to.
   */
  unbind(el) {
    document.removeEventListener('click', el.__vueClickOutside__)
    delete el.__vueClickOutside__
  },
}

```



```js
const clickOutside = {
  /**
   * 绑定方法
   * @param {Object} el - The element the directive is bound to.
   * @param {Object} binding - An vue directive object
   */
  bind(el, binding, vnode) {
    function clickHandler(e) {
      // 这里判断点击的元素是否是本身，是本身，则返回
      if (el.contains(e.target)) {
        return false;
      }
      // 判断指令中是否绑定了函数
      if (binding.expression) {
        // 如果绑定了函数 则调用那个函数，此处binding.value就是handleClose方法
        binding.value(e);
      }
    }
    // 给当前元素绑定个私有变量，方便在unbind中可以解除事件监听
    el.__vueClickOutside__ = clickHandler;
    document.addEventListener('click', clickHandler);
  },
  /**
   * 更新方法
   */
  update() {},
  /**
   * 销毁方法
   * @param {Object} el - The element the directive is bound to.
   */
  unbind(el, binding) {
    // 解除事件监听
    document.removeEventListener('click', el.__vueClickOutside__);
    delete el.__vueClickOutside__;
  },
};


directives: {clickOutside},
```

在组件中使用：

```html
<div v-click-outside="closeDialog"></div>
```

```js
<template>
<div v-clickoutside="eventHandler">something</div>
</template>

<script>
import clickoutside from 'directives/clickoutside.js'

export default {
  // ...somecode

  directives: {
    clickoutside,
  },
}
</script>
```

