<html>
<head>
  <title>3.05 -- Redux 4 -- 共享结构的对象提高性能</title>
  <basefont face="Consolas" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600363 (zh-CN, DDL); Windows/6.1.1 (Win64);"/>
  <style>
    body, td {
      font-family: Consolas;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="2035"/>
<h1>3.05 -- Redux 4 -- 共享结构的对象提高性能</h1>

<div>
<span><div>细心的朋友可以发现, 我们在之前的例子当中有着比较严重的性能问题的, 我们在每个渲染函数的开头打一些 log 看看:</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">function renderApp (appState) {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  console.log('render app...')</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  renderTitle(appState.title)</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  renderContent(appState.content)</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div><div><br style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"/></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">function renderTitle (title) {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  console.log('render title...')</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  const titleDOM = document.getElementById('title')</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  titleDOM.innerHTML = title.text</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  titleDOM.style.color = title.color</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div><div><br style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"/></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">function renderContent (content) {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  console.log('render content...')</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  const contentDOM = document.getElementById('content')</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  contentDOM.innerHTML = content.text</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  contentDOM.style.color = content.color</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div></div><div><br/></div><div>依旧执行一次初始化渲染, 和两次更新, 这里代码保持不变:</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">const store = createStore(appState, stateChanger)</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">store.subscribe(() =&gt; renderApp(store.getState())) // 监听数据变化</span></div><div><br style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"/></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">renderApp(store.getState()) // 首次渲染页面</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">store.dispatch({ type: 'UPDATE_TITLE_TEXT', text: '《React.js 小书》' }) // 修改标题文本</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">store.dispatch({ type: 'UPDATE_TITLE_COLOR', color: 'blue' }) // 修改标题颜色</span></div></div><div><br/></div><div>在控制台看到:</div><div><br/></div><div><img src="3.05 -- Redux 4 -- 共享结构的对象提高性能_files/Image.png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>前三个毫无疑问是第一次渲染打印出来的. 中间三个是第一次 store.dispatch 导致的, 最后三个是第二次 store.dispatch 导致的. 可以看到问题就是, 每当更新数据就会重新渲染整个 App, 但其实我们两次更新都没有动到 appState 里面的 content 字段的对象, 而动的是 title 字段. 其实并不需要重新 renderContent, 它是一个多余的更新操作, 现在我们需要优化它.</div><div><br/></div><div>这里提出的解决方案是, 在每个渲染函数执行渲染操作之前先做个判断, 判断传入的新数据和旧的数据是不是相同, 相同的话就不渲染了.</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">function renderApp (newAppState, oldAppState = {}) { // 防止 oldAppState 没有传入，所以加了默认参数 oldAppState = {}</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  if (newAppState === oldAppState) return // 数据没有变化就不渲染了</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  console.log('render app...')</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  renderTitle(newAppState.title, oldAppState.title)</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  renderContent(newAppState.content, oldAppState.content)</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div><div><br style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"/></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">function renderTitle (newTitle, oldTitle = {}) {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  if (newTitle === oldTitle) return // 数据没有变化就不渲染了</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  console.log('render title...')</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  const titleDOM = document.getElementById('title')</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  titleDOM.innerHTML = newTitle.text</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  titleDOM.style.color = newTitle.color</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div><div><br style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"/></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">function renderContent (newContent, oldContent = {}) {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  if (newContent === oldContent) return // 数据没有变化就不渲染了</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  console.log('render content...')</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  const contentDOM = document.getElementById('content')</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  contentDOM.innerHTML = newContent.text</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  contentDOM.style.color = newContent.color</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div></div><div><br/></div><div>然后我们用一个 oldState 变量保存旧的应用状态, 在需要重新渲染的时候把新旧数据传进去:</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">const store = createStore(appState, stateChanger)</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">let oldState = store.getState() // 缓存旧的 state</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">store.subscribe(() =&gt; {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  const newState = store.getState() // 数据可能变化，获取新的 state</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  renderApp(newState, oldState) // 把新旧的 state 传进去渲染</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  oldState = newState // 渲染完以后，新的 newState 变成了旧的 oldState，等待下一次数据变化重新渲染</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">})</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">...</span></div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 