# 缓存控制、代理服务器

http 系列中最核心的部分，也就是 http

TCP + HTTP 报文 + HTTP 缓存控制，面试官问的三大问题。

我们通过资料搜索可以对缓存控制有部分了解，但是更加深入地了解需要我们去亲手实践一下。

这样子我们就不需要去记忆所有的东西，而只需要记住几个关键词，就可以从某一点展开出去。

1. 讲解 Http 缓存控制规则、对应的报文字段、搭建 node.js 服务器测试缓存控制规则
2. 讲解代理、网关、隧道的概念

<https://imweb.io/topic/5795dcb6fb312541492eda8c>

<https://zhuanlan.zhihu.com/p/23299600>

这两篇文章，将它读懂，就可以深入理解 HTTP。



## 引言

【面试题】简述浏览器缓存是如何控制的

1.思路 1，

假设我们要向服务器发送一个请求要拿到一个链接，服务器找到对应的资源发送给浏览器，这是最简单的静态资源的获取过程。但是太简单了，有很多缺点。我每次请求都必须查找并返回资源，浪费带宽，那么我们就需要对这个过程进行优化。我们能否利用一些计算机资源将数据复用起来？

浏览器获取资源的时候就可以放到本地，那么下次再次请求相同资源的时候，就可以从本地直接拿这个资源。所以我们通过本地的缓存区，来复用资源。缺点是如果我们服务器上的资源变动了，我们这样子还是拿到的变化前的旧资源。

我们需要解决上面的问题。浏览器第一次请求 a 资源，服务器在发送文件的时候还附带发送一些额外的信息——过期时间，如 Expires: **Mon,10 Dec 1990 02:25:22GMT**。浏览器可以把这个文件和额外信息存到本地。当再次需要时就将浏览器时间与其进行比较

- 优点：缓存控制
- 缺点：控制的功能过于单一；格式容易写错



4.思路 4，缓存 + 更新机制升级

浏览器第一次请求资源的时候，服务器发送完整的文件并附带额外信息：

```shell
Cache-Control: max-age=300;
```

这个字段可以附带不同的控制信息，使得控制功能更加的强大。

下面是 Cache-Control 的接个常见功能：

- Public表示响应可被任何中间节点缓存，如 Browser <-- proxy1 <-- proxy2 <-- Server，中间的proxy可以缓存资源，比如下次再请求同一资源proxy1直接把自己缓存的东西给 Browser 而不再向proxy2要。
- Private表示中间节点不允许缓存，对于Browser <-- proxy1 <-- proxy2 <-- Server，proxy 会老老实实把Server 返回的数据发送给proxy1,自己不缓存任何数据。当下次Browser再次请求时proxy会做好请求转发而不是自作主张给自己缓存的数据。
- no-cache表示不使用 Cache-Control的缓存控制方式做前置验证，而是使用 Etag 或者Last-Modified字段来控制缓存
- no-store ，真正的不缓存任何东西。浏览器会直接向服务器请求原始文件，并且请求中不附带 Etag 参数(服务器认为是新请求)。
- max-age，表示当前资源的有效时间，单位为秒。

优点：控制功能更加强大

缺点：加入浏览器再次请求资源的时间超过了 max-age，这时候请求服务会重新返回完整文件资源。但是如果资源未经过修改，这样子就太浪费了，其实只要发送一个文件未被修改的标识就好了。



5.思路 5，缓存 + 更新机制终极版

浏览器第一次请求资源时，服务器会发送完整的文件并附带额外信息，其中 Etag 是对资源文件的编码，如果资源在服务端未被修改，这个值就不会变。

```shell
Cache-Control: max-age=300;
ETag:w/"e-cbxLFQW5zapn79tQwb/g6Q"
```

浏览器将资源文件和额外信息保存到本地。假如浏览器内在时间范围内请求文件，则直接从本地获取文件。假如在时间超时之后请求文件，浏览器发现缓存的文件已经过期了，于是向浏览器发送请求重新获取资源，在发送请求的时候附带保存的 ETag，服务器就收到请求后对 ETag 进行比较，如果二者不等则发送新文件和新 ETag，浏览器获取新文件并更新文件的 ETag。



我们之后用到的代码如下：

<https://github.com/jirengu/node-server>