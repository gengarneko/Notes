# 正则表达式入门



## 1 - 前言

### 1.1 目标

> 30分钟让你明白正则表达式是什么，并对它有一些基本的了解，让你可以在自己的程序或网页里使用它。

### 1.2 怎么学

别被下面那些复杂的表达式吓倒，只要跟着我一步步来，你会发现正则表达式其实并没有想象中的那么困难。当然，如果看完教程之后发现懂了很多却啥都不记得，那也是很正常的——只有练习才能掌握。

除了作为入门教程，本文还试图称为日常工作中的正则表达式语法参考手册。

> **清除格式** 本文格式约定：**专业术语** `元字符/语法格式` 正则表达式 正则表达式中的一部分（用于分析）对其进行匹配的源字符串

> **隐藏边注** 本文右边有一些注释，主要是用来提供一些相关信息，或者给没有程序员背景的读者

### 1.3 正则表达式到底是什么东西？

> 字符是计算机软件处理文字时最基本的单位，可能是字母、数字、标点符号、空格、换行符、汉字等。字符串是 0 个或更多字符的序列。文本也就是文字、字符串。说某个字符串匹配某个正则表达式，通常是指这个字符串里有一部分（或几部分）能满足表达式给出的条件。

编写处理字符串的程序或网页时，会经常有查找某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。总而言之，**正则表达式就是记录文本规则的代码。**



## 2 - 入门

> 由实例学习知识是最快的上手方式，下面提供了一些简单易懂的例子，带你了解正则。

- **阶段一**：假设要找出英文文章中所有的 *hi*，那么直接使用正则表达式 `hi`

  这几乎是最简单的正则表达式，可以精确匹配到这样的字符串：两字符组成，前一个是 h，后一个是 i。如果选中忽略大小写的选项，可以匹配 *hi, HI, Hi, hI* 这四种情况。

- **阶段二**：不幸的是，诸如 *history, high* 这种单词也包含 *hi*，那么我们 `hi` 这个正则就不够精确，因为我们只要 *hi*，这时候我们需要使用 `\bin\b`。

  `\b` 是正则表达式规定的一个特殊代码（**元字符，metacharacter**），代表着单词的开头或结尾，也就是单词的分界处。虽然通常英文的单词是由空格、标点或者换行符来分隔的，但是 `\b` 不匹配这些，它只**匹配一个位置**。

- **阶段三**：比如你匹配 `hi 后面不远跟一个 Lucy`，就应该用 `\bhi\b.*Lucy\b`。

  这里，`.`是另一个元字符，匹配**除了换行符以外的任意字符**。

  `*` 同样是元字符，它代表的是数量：它指定**前边的内容可以连续重复使用任意次以使整个表达式得到匹配**。

  `.*`组合在一起就表示了**任意数量的不包含换行的字符。**

  `\bhi\b.*Lucy\b` 意思就是：hi 加上任意个任意字符串（不含换行符）最后以 Lucy 结尾

如果使用其他连字符，我们就能构造出功能更强大的正则：

`0\d\d-\d\d\d\d\d\d\d\d` 匹配这样的字符串：以0开头，然后是两个数字，然后是一个连字号“-”，最后是8个数字。

也可以这么缩写：`0\d{2}-\d{8}`，这里 `\d `后面的 `{}` 中的数字就是连续重复匹配的次数。

> 更精确的说法：`\b` 匹配了的位置的前一个字符和后一个字符不全是 `\w`

> 换行符就是 `\n`



## 3 - 工具

### 3.1 在线的测试工具

https://www.regexpal.com

> 挂代理我居然打不开。。。。得在墙内登录

![](https://i.loli.net/2019/03/02/5c79ec67854cf.png)



### 3.2 可视化工具

https://regexper.com/

> 用于学习，构建和测试正则表达式的在线工具

![](https://i.loli.net/2019/03/02/5c79ed045c5fa.png)



### 3.3 在线测试工具

上面的只能在墙内看，我就重新找了个，如下：

https://regex101.com/#javascript

![](https://i.loli.net/2019/03/02/5c7a25ebc8470.png)





## 4 - 元字符

上面我们已经了解了一些很有用的**元字符**，如 `\b` ，`.` ，`*`，还有 `\d.` ，来几个例子：

- `\ba\w*\b` ：匹配以字母 *a* 开头的单词。先是某个单词开始处（`\b`），然后是字母 *a* ，然后是任意数量的**字母或数字**（`\w*`），最后是单词结束（`\b`）

- `\d+` ：匹配1个或更多连续的数字。这里的 `+` 是和 `*` 类似的元字符，不同的是 `*` 匹配重复任意次数（包括 0），而 `+` 则匹配 1 次或更多次。
- `\b\w{6}\b`：匹配长度为 6 的单词

常用元字符：

| 代码 | 说明                       |
| ---- | -------------------------- |
| `.`  | 匹配除换行符以外的任意字符 |
| `\w` | 匹配字母或数字或下划线     |
| `\s` | 匹配任意的空白符           |
| `\d` | 匹配数字                   |
| `\b` | 匹配单词的开始或结束       |
| `^`  | 匹配字符串的开始           |
| `$`  | 匹配字符串的结束           |

元字符 `^`和 `$` 都匹配一个位置，这和 `\b` 有点类似。`^` 匹配你要用来查找的字符串的开头，`$` 匹配结尾。这两个代码在验证输入的内容时非常有用，比如一个网站如果要求你填写的 QQ 号必须为 5 到 12 位，可以使用：`^\d{5,12}$`。

这里的 `{5,12}` 和前面介绍过的 `{2}` 是类似的，只不过 `{2}` 匹配只能不多不少，而 `{5,12}` 是重复次数不能少于 5 次，不能少于 12 次。

因为使用了 `^` 和 `$`，所以输入的整个字符串都要用来和 `\d{5,12}` 来匹配。

> 和忽略大小写的选项类似，有些正则表达式处理工具还有一个处理多行的选项。如果选中了这个选项，`^`和`$`的意义就变成了匹配行的开始处和结束处。

> **对中文/汉字的特殊处理是由.Net提供的正则表达式引擎支持的，其它环境下的具体情况请查看相关文档。**

> 正则表达式引擎通常会提供一个 “测试指定的字符串是否匹配一个正则表达式” 的方法，如 JavaScript 里的 RegExp.test() 方法或 .NET 里的 Regex.IsMatch() 方法。这里的匹配是指是字符串里有没有符合表达式规则的部分。如果不使用 `^ ` 和 `$` 的话，对于 `\d{5,12}` 而言，使用这样的方法就只能保证字符串里包含 5 到 12 连续位数字，而不是整个字符串就是 5 到 12 位数字。



## 5 - 字符转义

有时候我们查找 `.` 或者 `*` ，或者一些元字符本身的话，会有一些问题，因为这些元字符已经变成别的意思了（被转义了），我们没法准确找到这些元字符。出现这种情况，我们就得使用 `\` 来取消这些字符的特殊意义。所以，我们应该使用 `\.` 和 `\*`。当然，要查找 `\` 本身，你也得用 `\\`。

例子：`deerchao\.net` 匹配 *deerchao.net*，`C:\\Windows ` 匹配 *C:\Windows*。



## 6 - 重复

上面已经看过了 `*`，`+`，`{2}`，`{5,12}` 这几个匹配重复的方式了。下面是正则表达式中所有限定符（指定数量的代码，例如 *，{5,12} 等）：

| 代码\语法 | 说明              |
| --------- | ----------------- |
| `*`       | 重复零次或更多次  |
| `+`       | 重复一次或更多次  |
| `?`       | 重复零次或一次    |
| `{n}`     | 重复 n 次         |
| `{n,}`    | 重复 n 次或更多次 |
| `{n,m}`   | 重复 n 到 m 次    |

例子：

- `Windows\d+`：匹配 Windows 后面跟 1 个或更多数字
- `^\w?`：匹配一行的第一个单词（或整个字符串的第一个单词，具体匹配哪个意思得看选项设置）



## 7 - 字符类

如果想要查找 *数字、字母或数字、空白* 是很简单的，因为对应这些字符集合的元字符是已经存在的了，不过要想匹配像元音字母 *a、e、i、o、u* 这种没有事先定义元字符的字符集合该怎么做呢？我们使用 **方括号** `[]`，比如 `[aeiou]` 就匹配**任何一个英文元音字母**，`[.?!]` 匹配标点符号（*. 或  ? 或  !*）。

我们也可以指定一个字符范围，比如  `[0-9]` 代表的含义就和 `\d` 就是完全一样的；同理 `[a-z0-9A-Z]` 也完全等同于 `\w` （如果只考虑英文的话）。

接着我们来看一个更复杂的表达式：`\(?0\d{2}[) -]?\d{8}`

这个表达式可以匹配几种格式的电话号码，比如 `(010)88886666`、`022-22334455`、`02912345678`

-  `\(?`：出现一个个转义字符，出现 0 或 1 次
- `0\d{2}`：0 + 两个数字
- `[) -]?`：匹配一个括号、空格或者连字符
- `\d{8}`：接 8 个数字

> `(` 和 `)` 也是元字符，后面的分组章节里会提到，所以在这里需要使用转义。



## 8 - 分支条件

上面的正则并不完美，因为它可以匹配 `010)12345678` 或者 `(022-87654321` 这种错误格式。解决这个问题我们使用**分支条件**。正则表达式中的分支条件指的是：存在几种规则，只要满足其中任何一个，就会被当成匹配。我们使用 `|` 来分隔各个规则。以下是例子：

- `0\d{2}-\d{8}|0\d{3}-\d{7}`：可以匹配形如 `010-12345678` 和 `0376-2233445` 的号码
- `\(0\d{2}\)[- ]?\d{8}|0\d{2}[- ]?\d{8}`：号码前三位可以用括号括起来也可以不用
- `\d{5}-\d{4}|\d{5}`：匹配没过的邮政编码，`五位数字` 或者 `五位数字 + 连字符 + 九位数字` ，这个例子告诉我们：**使用分支条件时，要注意各个条件的顺序。**如果改成 `\d{5}|\d{5}-\d{4}`，就会只匹配 5 位 的邮编，因为匹配分支时，会从左到右测试每个条件，满足条件则不会执行下一个条件。



## 9 - 分组

我们已经知道了重复单个字符怎么写（`[a-z]{5}`），那么多个字符的重复又该如何实现呢？我们可以使用 `()` 来指定子表达式（也成为 **分组**），然后对子表达式进行重复。

`(\d{1,3}\.){3}\d{1,3}` 是一个简单的 IP 地址匹配表达式“

- `\d{1,3}\.`：匹配 1 到 3 位的数字加上一个 `.`
- `(\d{1,3}\.){3}`：将上面的分组重复三次
- `\d{1,3}`：最后再加上一个三位数字

但是问题又来了，这个正则将匹配 `256.300.888.999` 这种错误地址。我们在正则表达式中无法使用算数比较，所以只能使用冗长的分组、选择、字符类来描述一个正确的 IP 地址：`((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)`

### 9.1 分析一下 IP4 的正则表达式子：

先来拆分：

- 250-255：三位数，百位是 2，十位是 5，个位是 0-5，用正则表达式可以写成：`25[0-5]`
- 200-249：三位数，百位是 2，十位是 0-4，个位是 0-9，用正则表达式可以写成：`2[0-4]\d`
- 0-199：这个可以继续拆：
  - 0-9：一位数，个位是 0-9，用正则表达式可以写成：`\d`
  - 10-99：二位数，十位是 1-9，个位是 0-9，用正则表达式可以写成：`[1-9]\d`
  - 100-199：三位数，百位是 1，十位是 0-9，个位是 0-9，用正则表达式可以写成：`1\d{2}`

再来合并：

- 0-99：`[0-9]?\d`
- 0-199：`1\d{2}|[1-9]?\d`

我们来优化一下：

- 0-199：`[01]?\d\d?`

> IP 地址中每个数字都不能大于 255，那么 01.02.03.04 这样前面带有 0 的数字，是不是正确的 IP 地址呢？答案是：是的，IP 地址里的数字可以包含有前导 0（leading zeroes）。



## 10 - 反义

有时候想找不是这个条件的字符，这时候就需要用到**反义**（相反的意思，很好理解吧）

| 代码/语法  | 说明                                       |
| ---------- | ------------------------------------------ |
| `\W`       | 匹配任意不是字母，数字，下划线，汉字的字符 |
| `\S`       | 匹配任意不是空白符的字符                   |
| `\D`       | 匹配任意非数字的字符                       |
| `\B`       | 匹配不是单词开头或结束的位置               |
| `[^X]`     | 匹配除了x以外的任意字符                    |
| `[^aeiou]` | 匹配除了aeiou这几个字母以外的任意字符      |

例子：

- `\S+` 匹配不包含空白符的字符串
- `<a[^>]+>` 匹配用尖括号括起来的以a开头的字符串。



## 11 - 后向引用

当我们使用小括号指定一个子表达式之后，就要对这个子表达式的文本进行匹配，即此分组捕获的内容，可以在表达式或者其它程序中作进一步的处理。一般情况下，每个分组都会自动拥有一个组号，规则是：**从左到右以分组的左括号为标志，把第一次出现的分组的组号定为 1，第二个为 2，以此类推。**

**后向引用**用于重复搜索前面某个分组匹配的文本，例如，`\1` 代表分组 1 匹配的文本，我们来看一下例子：

`\b(\w+)\b\s+\1\b` 可以用来匹配重复的单词，像 *hi hi*，*hei hei*，这种的。分析：

- `\b(\w+)\b`：首先是一个单词，被捕获为编号为 1 的分组中
- `\s+`：接着是一个或多个空格
- `\1\b`：最后是分组 1 中捕获的内容，也就是重复分组 1 的单词。

你也可以自定义子表达式的**组名**。要指定一个子表达式的组名，用这样的语法：`(?<Word>\w+)` 或者 `(?'Word'\w+))`。这时候就可以使用 `\k<Word> `来捕获这个分组，这样改写：`\b(?<Word>\w+)\b\s+\k<Work>\b`

| 分类     | **代码/语法**  | **说明**                                                     |
| -------- | -------------- | ------------------------------------------------------------ |
| 捕获     | `(exp)`        | 匹配 exp，并捕获文本到自动命名的组里                         |
| 捕获     | `(?<name>exp)` | 匹配 exp，并捕获文本到名称为 name 的组里，也可以写成 (?'name'exp) |
| 捕获     | `(?:exp)`      | 匹配 exp，不捕获匹配的文本，也不给此分组分配组号             |
| 零宽断言 | `(?=exp)`      | 匹配 exp 前面的位置                                          |
| 零宽断言 | `(?<=exp)`     | 匹配 exp 后面的位置                                          |
| 零宽断言 | `(?!exp)`      | 匹配后面跟的不是 exp 的位置                                  |
| 零宽断言 | `(?<!exp)`     | 匹配前面不是 exp 的位置                                      |
| 注释     | `(?#comment)`  | 不产生任何影响，用于提供注释                                 |

我们已经讨论了前两种语法，第三个 `(?:exp)` 不会改变正则表达式的处理方式，只是这样的组匹配的内容不会像前两种那样呗捕获到某个组里面，也不会拥有组号。为什么要这样做呢？一般来说是为了节省资源，提高效率。

比如说输入的数据是整数，这么写：

```
^([1-9][0-9]*|0)$
```

这时候的 `|` 仅仅用来分隔分支条件，没有捕获的需求，那么我们就可以使用 `(?:exp)` 来定义它为非捕获组。

```
^(?:[1-9][0-9]*|0)$
```

这只是个简单的例子，如果我们来做一个日期正则：

```
^(?:(?:(?:(?:(?:1[6-9]|[2-9]\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00)))([-/.])(?:0?2\1(?:29)))|(?:(?:(?:1[6-9]|[2-9]\d)?\d{2})([-/.])(?:(?:(?:0?[13578]|1[02])\2(?:31))|(?:(?:0?[13-9]|1[0-2])\2(29|30))|(?:(?:0?[1-9])|(?:1[0-2]))\2(?:0?[1-9]|1\d|2[0-8]))))$
```

可见极大优化了资源利用率。**有的时候我们不得不用 ()，而 () 默认情况下会将其中 exp 匹配的内容捕获到组里，而有些情况我们只是判断规则，或者后面并不需要对此处 () 中匹配的内容进行引用时，就没有必要把它捕获到组里了，一方面会造成资源的浪费，另一方面会降低效率，这时候就要用到非捕获组了。**

> 其实，组号分配还不像说的这么简单的：
>
> - 分组 0 对应整个正则表达式
>
> - 实际上组号分配过程要从左向右扫描两遍：
>
>   - 第一遍给未命名组分配
>   - 第二遍给命名组分配
>
>   因此所有命名组的组号都大于未命名
>
> - 你可以使用 `(?:exp)` 这样的语法来剥夺一个分组对组号分配的参与权。



## 12 - 零宽断言

接下来的四个用于查找在某些内容的之前或之后的东西，但是有不包含这些内容本身的时候，零宽断言就起到作用了。

也就是说它们像 `\b`， `^`，`$` 那样用于指定一个位置，这个位置应该满足一定的条件（即断言），因此它们也被称为**零宽断言**。

- `(?=exp)`：**零宽度正预测先行断言**，它断言自身出现的位置的后面能匹配表达式 exp。

  比如`\b\w+(?=ing\b)`，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找 *I'm singing while you're dancing.* 时，它会匹配 sing 和 danc。

- `(?<=exp)`：**零宽度正回顾后发断言**，它断言自身出现的位置的前面能匹配表达式 exp。

  比如 `(?<=\bre)\w+\b` 会匹配以 re 开头的单词的后半部分（除了 re 以外的部分），例如在查找 *reading a book* 时，它匹配 ading。

假如你想要给一个很长的数字中每三位间加一个逗号（当然是从右边加起了），你可以这样查找需要在前面和里面添加逗号的部分：`((?<=\d)\d{3})+\b`，用它对 *1234567890* 进行查找时结果是 234567890。

下面这个例子同时使用了这两种断言：

​	`(?<=\s)\d+(?=\s)` 匹配以空白符间隔的数字（再次强调，不包括这些空白符）。

> 断言用来声明一个应该为真的事实。正则表达式中只有当断言为真时才会继续进行匹配。



## 13 - 负向零宽断言

当我们的目的不是去匹配某个字符，而是只想要该字符是否出现过，怎么办？例如，如果我们想要查找的单词中出现了字母 q，但是字母 q 的后面跟着的不是字母 u ，这种情况我们尝试：

`\b\w*q[^u]\w*\b` 匹配包含**后面不是字母 u 的字母 q**的单词。但是这样子会发现它匹配不了 `Benq` 这种以 *q* 结尾的单词，因为 `[^u]` 总是要匹配一个字符的，这样它就可能会匹配到单词分隔符，可能会形成匹配两个单词的情况，比如匹配到：*Iraq fighting* 

**负向零宽断言** 能解决这样的问题，因为它只匹配一个位置，并不**消费**任何字符。我们这么写 `\b\w*q(?!u)\w*\b`

**零宽度负预测先行断言** `(?!exp)`，断言此位置的后面不能匹配表达式 exp。例如：

- `\d{3}(?!\d)` 匹配三位数字，而且这三位数字的后面不能是数字；
- `\b((?!abc)\w)+\b` 匹配不包含连续字符串 abc 的单词。

**零宽度负回顾后发断言** `(?<!exp)` ，来断言此位置的前面不能匹配表达式 exp：

- `(?<![a-z])\d{7}` 匹配前面不是小写字母的七位数字。

一些更复杂的例子：

- `(?<=<(\w+)>).*(?=<\/\1>)` 匹配不包含属性的简单HTML标签内里的内容。

  - `(?<=<(\w+)>)` 指定了这样的**前缀**：被尖括号括起来的单词（形如 <p>）
  - `.*` 任意字符串
  - `(?=<\/\1>)` 注意 `\/`，用到了前面提过的字符转义；`\1` 则是一个反向引用，引用捕获到的第一组。

  这个例子就是匹配的标签之间的内容。

> 请详细分析表达式`(?<=<(\w+)>).*(?=<\/\1>)`，这个表达式最能表现零宽断言的真正用途。



## 14 - 注释

小括号还有一种用途，就是通过语法 `(?#comment)` 来包含注释，例如：

```
2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)
```

如果要包含注释，最好是启用“忽略模式里的空白符”选项，因为这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略。启用这个选项后，在#后面到这一行结束的所有文本都将被当成注释忽略掉。

例如，我们可以前面的一个表达式写成这样：

```
(?<= # 断言要匹配的文本的前缀
<(\w+)> # 查找尖括号括起来的字母或数字(即HTML/XML标签)
) # 前缀结束
.* # 匹配任意文本
(?= # 断言要匹配的文本的后缀
<\/\1> # 查找尖括号括起来的内容：前面是一个"/"，后面是先前捕获的标签
) # 后缀结束
```



## 15 - 贪婪与懒惰

当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配**尽可能多**的字符。以这个表达式为例：`a.*b`，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索 aabab 的话，它会匹配整个字符串 *aabab*。这被称为**贪婪**匹配。

有时，我们更需要**懒惰**匹配，也就是匹配**尽可能少**的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号 `?`。这样 `.*?` 就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的例子吧：

`a.*?b ` 匹配最短的，以a开始，以b结束的字符串。如果把它应用于 *aabab* 的话，它会匹配 aab（第一到第三个字符）和ab（第四到第五个字符）。

懒惰限定符

| 代码/语法 | 说明                              |
| --------- | --------------------------------- |
| `*?`      | 重复任意次，但尽可能少重复        |
| `+?`      | 重复 1 次或更多次，但尽可能少重复 |
| `??`      | 重复 0 次或 1 次，但尽可能少重复  |
| `{n,m}?`  | 重复 n 到 m 次，但尽可能少重复    |
| `{n,}?`   | 重复 n 次以上，但尽可能少重复     |

> 为什么匹配得到的是 aab 而不是 ab 呢？因为另一条规则，比 贪婪/懒惰 规则优先级更高：The match that begins earliest wins。



## 16 - 处理选项

以下是 .Net 中常用到的正则表达式选项：

| **名称**                          | **说明**                                                     |
| --------------------------------- | ------------------------------------------------------------ |
| IgnoreCase(忽略大小写)            | 匹配时不区分大小写。                                         |
| Multiline(多行模式)               | 更改`^`和`$`的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,`$`的精确含意是:匹配\n之前的位置以及字符串结束前的位置.) |
| Singleline(单行模式)              | 更改.的含义，使它与每一个字符匹配（包括换行符\n）。          |
| IgnorePatternWhitespace(忽略空白) | 忽略表达式中的非转义空白并启用由`#`标记的注释。              |
| ExplicitCapture(显式捕获)         | 仅捕获已被显式命名的组。                                     |

>  是不是只能同时使用多行模式和单行模式中的一种？答案是：不是。这两个选项之间没有任何关系，除了它们的名字比较相似（以至于让人感到疑惑）以外。



## 17 - 衡组/递归匹配

有时候我们需要匹配像 `( 100 * ( 50 + 15 ) )` 这种嵌套的层次结构，简单使用 `\(.+\)` 只匹配最左和最右之间的内容，加入左右括号不匹配，数量不等，形如 `( 5 / ( 3 + 2 ) ) )` 匹配就很麻烦。

为了避免 `(` 和 `\(` 把你搞糊涂，我们还是用尖括号代替圆括号吧。现在我们的问题变成了如何把 *xx <aa <bbb> <bbb> aa> yy*这样的字符串里，最长的配对的尖括号内的内容捕获出来？

这里就需要用到以下的语法构造：

- `(?'group')`：把捕获的内容命名为 group，并压入**堆栈（Stack）**
- `(?'-group')`：从堆栈顶部弹出名为 group 的捕获内容，如果堆栈本来为空，则本分组的匹配失败
- `(?(group)yes|no)`：如若堆栈存在以名为 group 的捕获内容的话，继续匹配 yes 部分的表达式，否则继续匹配 no
- `(?!)`：零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败

```
<                         #最外层的左括号
    [^<>]*                #最外层的左括号后面的不是括号的内容
    (
        (
            (?'Open'<)    #碰到了左括号，在黑板上写一个"Open"
            [^<>]*       #匹配左括号后面的不是括号的内容
        )+
        (
            (?'-Open'>)   #碰到了右括号，擦掉一个"Open"
            [^<>]*        #匹配右括号后面不是括号的内容
        )+
    )*
    (?(Open)(?!))         #在遇到最外层的右括号前面，判断黑板上还有没有没擦掉的"Open"；如果还有，则匹配失败

>                         #最外层的右括号
```

最常见的应用场景就是匹配 HTML，我们来匹配嵌套的 `div` 标签：

```
<div[^>]*>[^<>]*(((?'Open'<div[^>]*>)[^<>]*)+((?'-Open'</div>)[^<>]*)+)*(?(Open)(?!))</div>.
```



## 18 - 常用代码

### 18.1  校验密码强度

密码的强度必须是包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间。

```text
^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$
```

### 18.2 校验中文

字符串仅能是中文。

```text
^[\\u4e00-\\u9fa5]{0,}$
```

### 18.3 由数字、26 个英文字母或下划线组成的字符串

```text
^\\w+$
```

### 18.4 校验E-Mail 地址

同密码一样，下面是E-mail地址合规性的正则检查语句。

```text
[\\w!#$%&'*+/=?^_`{|}~-]+(?:\\.[\\w!#$%&'*+/=?^_`{|}~-]+)*@(?:[\\w](?:[\\w-]*[\\w])?\\.)+[\\w](?:[\\w-]*[\\w])?
```

### 18.5 校验身份证号码

下面是身份证号码的正则校验。15 或 18位。

```text
15位：
^[1-9]\\d{7}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}$
18位：
^[1-9]\\d{5}[1-9]\\d{3}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}([0-9]|X)$
```

### 18.6 校验日期

“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。

```text
^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$
```

### 18.7 校验金额

金额校验，精确到2位小数。

```text
^[0-9]+(.[0-9]{2})?$
```

### 18.8 校验手机号

下面是国内 13、15、18开头的手机号正则表达式。（可根据目前国内收集号扩展前两位开头号码）

```text
^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$
```

### 18.9 判断IE的版本

IE目前还没被完全取代，很多页面还是需要做版本兼容，下面是IE版本检查的表达式。

```text
^.*MSIE [5-8](?:\\.[0-9]+)?(?!.*Trident\\/[5-9]\\.0).*$
```

### 18.10 校验IP-v4地址

IP4 正则语句。

```text
\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b
```

### 18.11 校验IP-v6地址

IP6 正则语句。

```text
(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))
```

### 18.12 检查URL的前缀

应用开发中很多时候需要区分请求是HTTPS还是HTTP，通过下面的表达式可以取出一个url的前缀然后再逻辑判断。

```text
if (!s.match(/^[a-zA-Z]+:\\/\\//))
{
    s = 'http://' + s;
}
```

### 18.13 提取URL链接

下面的这个表达式可以筛选出一段文本中的URL。

```text
^(f|ht){1}(tp|tps):\\/\\/([\\w-]+\\.)+[\\w-]+(\\/[\\w- ./?%&=]*)?
```

### 18.14 文件路径及扩展名校验

验证windows下文件路径和扩展名（下面的例子中为.txt文件）

```text
^([a-zA-Z]\\:|\\\\)\\\\([^\\\\]+\\\\)*[^\\/:*?"<>|]+\\.txt(l)?$
```

### 18.15 提取Color Hex Codes

有时需要抽取网页中的颜色代码，可以使用下面的表达式。

```text
^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$
```

### 18.16 提取网页图片

假若你想提取网页中所有图片信息，可以利用下面的表达式。

```text
\\< *[img][^\\\\>]*[src] *= *[\\"\\']{0,1}([^\\"\\'\\ >]*)
```

### 18.17 提取页面超链接

提取html中的超链接。

```text
(<a\\s*(?!.*\\brel=)[^>]*)(href="https?:\\/\\/)((?!(?:(?:www\\.)?'.implode('|(?:www\\.)?', $follow_list).'))[^"]+)"((?!.*\\brel=)[^>]*)(?:[^>]*)>
```

### 18.18 查找CSS属性

通过下面的表达式，可以搜索到相匹配的CSS属性。

```text
^\\s*[a-zA-Z\\-]+\\s*[:]{1}\\s[a-zA-Z0-9\\s.#]+[;]{1}
```

### 18.19 抽取注释

如果你需要移除HMTL中的注释，可以使用如下的表达式。

```text
<!--(.*?)-->
```

### 18.20 匹配HTML标签

通过下面的表达式可以匹配出HTML中的标签属性。

```text
<\\/?\\w+((\\s+\\w+(\\s*=\\s*(?:".*?"|'.*?'|[\\^'">\\s]+))?)+\\s*|\\s*)\\/?>
```



## 19 - 总结

上面的只是常用的匹配语法，完整地参见[关于正则表达式语言元素的 MSDN 在线文档](http://msdn.microsoft.com/zh-cn/library/az24scfc.aspx)。

30 分钟看完？我骗你的哇，老铁，不然你怎么看得下去呢？