# 分布式系统架构笔记

先抛出几个问题：

- 对分布式系统了解有多少
- 分布式系统相对于单机或集中式系统有啥优势
- 分布式系统主要用于解决什么问题
- 分布式系统面临的最大挑战是什么



> 最大的挑战：数据一致性问题，比如数据库主从延迟，导致高并发情况下读取数据不一致

> 主要解决的问题之一：单点故障，通过负载均衡解决单点性能和可用性问题

> 看起来，集群在多台服务器上部署相同的应用，分布式是在多台服务器中部署的不同服务模块。但是集群部署就是分布式系统的体现，只是不同业务部署方式不同。



## 1 - 分布式出现背景及面临的问题

### 1.1 出现背景

> 因为集中式系统不能满足互联网爆炸式增长的需求。

一方面随着系统变得越来越复杂，集中式系统的成本越来越高，这个成本包含两个方面

- 人才成本，机器成本：大型主机动辄几百上千万
- 集中式系统明显的单点问题：扩展困难，与之相对，随着技术发展分布式有了硬件基础

> 关于集中式转型分布式，最出名的就是阿里去 IOE 运动（IBM、Oracle、EMC 存储设备）

分布式系统是一个硬件或软件组件分布在不同的网络计算机上，彼此之间仅仅通过消息传递进行通信和协调的系统，具备分布性、对等性、并发性等特征。

### 1.2 面临问题

分布式系统可以很好的解决系统扩容、可用性以及降低成本，但是在部署和实践中要解决其存在的问题：

- **通信异常**：分布式系统需要在各个节点之间进行网络通信，而网络本身是不可靠的，因此每次网络通信都会伴随着网络不可用的风险（比如硬件设备异常），另外响应延迟也会远大于单机操作（网络通信比内存操作肯定是慢很多的）
- **三态**：由于网络是不可靠的，分布式系统每次请求与响应，存在特有的 ”三态“ 概念，即成功、失败与超时。出现超时状态时，网络通信发起方是无法确定当前请求是否被成功处理的。
- **节点故障**：分布式系统的服务器节点出现宕机或者 “僵死”，导致部分节点不可用，进而引起分布式一致性问题。



## 2 - 从单机事务到分布式事务

> 此处事务指的是数据库事务

### 2.1 单机事务

> ACID 特征：原子性、一致性、隔离性和持久性

单机上我们解决数据一致性的办法是通过数据库事务，数据库事务具有 ACID 特征，好处是：

- 保证了当多个应用程序并发访问数据的时候，事务可在这些程序之间提供一个隔离方法，以防止彼此之间的操作互相干扰
- 事务为数据库操作提供了一个从失败中恢复到正常状态的方法，这样数据库即使在异常状态下仍然能保持数据一致性

### 2.2 分布式事务

分布式事务涉及到操作多个数据库的事务，分布式事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于分布式系统的不同节点上。一个分布式事务可以看作是由多个分布式的操作序列组成的，通常可以把这一系列分布式的操作序列称为子事务，但由于在分布式事务中，各个子事务的执行是分布式的，因此要实现一种能够保证 ACID 特性的分布式事务处理系统就显得格外复杂。

为了解决分布式事务问题，这就提出了两个著名理论：**CAP 理论 **和 **BASE 理论**

- **CAP 理论 **认为一个分布式系统不可能同时满足 CAP （Consistency、Availability、Partition tolerance）也就是一致性、可用性和分区容错性这三个基本需求，最多只能同时满足其中两项
- **BASE 理论 **是 Basically Available（基本可用）、Soft state（软状态）和 Eventually consistent（最终一致性）三个单词的简写，是对 CAP 中一致性和可用性权衡的结果，其来源于对大规模互联网分布式实践的总结，是基于 CAP 定理逐步演化而来的，其核心思想是即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）

> BASE 理论面向的是大型高可用可扩展的分布式系统，和传统事务的 ACID 特性是相反的，它完全不同于 ACID 的强一致性模型，而是提出通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态（弱一致性）。



## 3 - 一致性协议之 2PC、3PC

当一个事务操作需要跨越多个分布式节点的时候（分布式事务），为了保持事务处理的 ACID 特性，就需要引入一个称为 “协作者” 的组件来同一调度所有分布式节点的执行逻辑，这些被调度的分布式节点则被称为 “参与者”。协调者负责调度参与者的行为，并最终决定这些参与者是否要把事务真正进行提交。基于这个思想，衍生出了二阶段提交和三阶段提交两种协议。

### 3.1 2PC

2PC（Two-Phase Commit），即二阶段提交，是计算机网络尤其是数据库领域内，为了使基于分布式系统架构下所有节点在进行事务处理过程中能够保持原子性和一致性而设计的一种算法。二阶段提交是一个**强一致性**算法，目前，绝大部分的关系型数据库都是采用二阶段提交协议来完成分布式事务处理的，利用该协议能够非常方便地完成所有分布式事务参与者的协调，**统一决定事务的提交或回滚**，从而能够有效地保证分布式数据一致性。

顾名思义，二阶段提交协议分为两个阶段：

- 提交事务请求（投票阶段）
  - 事务询问：协调者向所有参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待响应
  - 执行事务：各个参与者执行事务操作，并将 Undo 和 Redo 信息记入事务日志
  - 各参与者向协调者反馈事务的响应：成功执行，反馈 Yes，表示可执行；否则返回 No
- 执行事务提交（两种情况）
  - 协调者从所有参与者都获得 Yes 响应，会执行事务提交
    - 发送提交请求：协调者向所有参与者节点发送 Commit 请求
    - 事务提交：参与者接收到 Commit 请求后，会正式执行事务提交操作，并在完成提示之后释放事务资源
    - 反馈结果：参与者完成事务提交，向协调者发送 Ack 消息
    - 完成事务：协调者接收到所有参与者反馈的 Ack 消息，完成事务
  - 存在 No 反馈，即任何一个参与者反馈了 No 或者等待超时，就会中断事务
    - 发送回滚请求：协调者向所有参与者节点发送 Rollback 请求
    - 事务回滚：参与者收到请求，会利用阶段一中的记录的 Undo 信息来执行事务回滚操作，回滚完释放资源
    - 反馈结果：参与者在完成事务回滚之后，向协调者发送 Ack 消息
    - 中断事务：协调者接收到所有参与者反馈的 Ack 消息后，完成事务中断

优缺点总结：

- 优点：原理简单，实现方便
- 缺点：同步阻塞、单点问题（协调者）、脑裂（数据不一致）、过于保守（容错机制不完善）

### 3.2 3PC

3PC（Three-Phase Commit），即三阶段提交，是 2PC 的改进版，将其二阶段重新划分，最终形成为 CanCommit、PreCommit 和 doCommit，三个阶段如下：

- 阶段一：CanCommit
  - 事务询问：协调者向所有的参与者发送一个包含事务内容的 canCommit 请求，询问是否可以执行事务提交操作，并开始等待各参与者的响应
  - 各参与者向协调者反馈事务询问的响应：参与者在接收到来自协调者的 canCommit 请求后，正常情况下，如果其自身认为可以顺利执行事务，那么会反馈 Yes 响应，并进入预备状态，否则反馈 No 响应

- 阶段二：PreCommit

  假如协调者从所有的参与者获得的反馈都是 Yes 响应，那么就会执行事务预提交：

  - 发送预提交请求：协调者向所有参与者节点发出 preCommit 的请求，并进入 Prepared 阶段。
  -  事务预提交：参与者接收到 preCommit 请求后，会执行事务操作，并将 Undo 和 Redo 记录到事务日志中。

  假如任何一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务：

  - 发送中断请求：协调者向所有参与者节点发出 abort 请求。
  - 中断事务：无论是收到来自协调者的 abort 请求，或者是在等待协调者请求过程中出现超时，参与者都会中断事务

- 阶段三：doCommit

  - 协调者从所有的参与者获得的反馈都是 Yes 响应，则执行提交：

    - 发送提交请求：进入这一阶段，假设协调者处于正常工作状态，并且它接收到了来自所有参与者的Ack响应，那么它将从“预提交”状态转换到“提交”状态，并向所有的参与者发送 doCommit 请求。
    -  事务提交：参与者接收到 doCommit 请求后，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的事务资源。
    -  反馈事务提交结果：参与者在完成事务提交之后，向协调者发送 Ack 消息。
    - 完成事务：协调者接收到所有参与者反馈的 Ack 消息后，完成事务。

  - 任何一个参与者向协调者反馈了 No 响应，或者在等待超时之后，协调者会中断事务：

    - 发送中断请求：协调者向所有的参与者节点发送 abort 请求。
    - 事务回滚：参与者接收到 abort 请求后，会利用其在阶段二中记录的 Undo 信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源。
    - 反馈事务回滚结果：参与者在完成事务回滚之后，向协调者发送 Ack 消息。
    - 中断事务：协调者接收到所有参与者反馈的 Ack 消息后，中断事务。

    > 注：在doCommit 阶段，如果参与者无法及时接收到来自协调者的 doCommit 或者 abort 请求时，会在等待超时之后，会继续进行事务的提交。

优缺点总结：

- 优点：相较于二阶段提交协议，三阶段提交协议最大的优点就是降低了参与者的阻塞范围，并且能够在出现单点故障后继续达成一致（原因结合上面的注）。
-  缺点：三阶段提交协议在去除阻塞的同时也引入了新的问题，那就是在参与者接收到 preCommit 消息后，如果网络出现分区，此时协调者所在的节点和参与者无法进行正常的网络通信，在这种情况下，该参与者依然会进行事务的提交，这必然出现数据的不一致性。

> 了解了 2PC 和 3PC 之后，我们可以发现，无论是二阶段提交还是三阶段提交都无法彻底解决分布式的一致性问题。Google Chubby的作者Mike Burrows说过， 世上只有一种一致性算法，那就是Paxos，所有其他一致性算法都是Paxos算法的不完整版。下一次我们就来介绍这个公认为难于理解但是行之有效的Paxos算法。



## 4 - 大名鼎鼎的Paxos算法

Paxos 是一个基于消息传递的一致性算法，Leslie Lamport 在 1990 年提出，近几年被广泛应用于分布式计算中。有个问题要提一下，Paxos 有一个前提：没有拜占庭将军问题。就是说 Paxos 只有在一个可信的计算环境中才能成立，这个环境是不会被入侵所破坏的。

这里简单描述一下：

Paxos 描述了这样一个场景，有一个叫做 Paxos 的小岛（Island）上面住了一批居民，到上面所有的事情由一群特殊的人决定，他们叫做议员（Senator），议员的总数（SenatorCount）是确定的，不能更改。岛上每次环境的变更都需要通过一个提议（Proposal），每个提议都有一个编号（PID），这个编号是一直增长的，不可以倒退。每次提议都需要超过半数（SenatorCount/2 + 1）的议员同意才能生效。每个议员只会同意大于当前编号的提议（也就是新的提议），包括已生效的和未生效的。如果收到小于当前编号的提议，则会拒绝，并告知对方：你的提议已经有人提出过了。这里的当前编号是每个议员在自己的记事本上（日志）记录的编号，他会不断更新这个编号，整个议会无法保证所有议员的记事本上的编号总是相同的（弱一致性）。现在议会有一个目标：保证所有议员对于提议都能达成一致的看法。

好了，现在议会开始运作，所有议员一开始记事本上记录的都是 0。有一个议员提出一个提议：上调油价，+3毛钱。他首先看了下记事本，嗯，当前编号 0，那我提出的就是 1，于是给所有议员发消息：1 号提议：油价 + 3毛。其他议员看了下记事本，嗯，当前编号为 0，这个 1 号提议是可以接受的，于是记录下这个提议并回复：我们已收到你的 1 号提议 ，这时候大家记事本上编号为 1。当发起者收到超半数的回复，就发出通知：1 号提议生效！收到生效通知的议员会将 1 号提议由记录更改为正式法令，当有人问他油价变化多少，它会查看法令并回复：上调 3 毛钱。

现在看怎么解决这个过程中的冲突：假设三个议员 S1、S2、S3，S1 和 S2 同时发起一个提议：1 号提议，上调油价。S1 想上调 3 毛，S2 想上调 5 毛。结果 S3 先收到 S1 的提议，于是按照上面的过程回复收到信息。接着他收到 S2 的提案，查了下记事本，根据程序拒绝了这个提案。于是 S2 被拒绝，S1 正式宣布 1 号生效。S2 向 S1 或者 S3 打听并更新了 1 号法令内容，然后他可以选择继续发起 2 号提议。

Paxos 算法引入了 “过半” 的理念，通俗地讲就是少数服从多数。同时 Paxos 算法支持分布式节点角色之间的轮换，这极大避免了分布式单点的出现，因此 Paxos 算法既解决了无限期等待的问题，也解决了 “脑裂” 的问题，是目前最优秀的分布式一致性协议之一。

在这种一致性算法中，有三种参与角色，我们用 Proposer、Acceptor 和 Learner 来表示，具体实现中，一个进程可能充当不止一种角色。

**提案的选定**

- 阶段一
  - Proposer 选择一个提案编号 Mn，然后向 Acceptor 的某个超过半数的子集成员发送编号为 Mn 的 Prepare 请求。
  - 如果一个 Acceptor 收到一个编号为 Mn 的 Prepare 请求，且编号 Mn 大于该 Acceptor 已经响应的所有 Prepare 请求的编号，那么它就会将它已经批准过的最大编号的提案作为响应反馈给 Proposer，同时该 Acceptor 会承诺不会再批准任何编号小于 Mn 的提案。
- 阶段二
  - 如果 Proposer 收到来自半数以上的 Acceptor 对于其发出的编号为 Mn 的 Prepare 请求的响应，那么它就会发送一个针对［Mn，Vn］提案的 Accept 请求给 Acceptor。注意，Vn 的值就是收到的响应中编号最大的提案的值，如果响应中不包含任何提案，那么它就是任意值。
  -  如果 Acceptor 收到这个针对［Mn，Vn］提案的 Accept 请求，只要该 Acceptor 尚未对编号大于 Mn 的Prepare 请求做出响应，它就可以通过这个提案。

> 活锁问题：假设存在这样一种极端情况，有两个 Proposer 依次提出了一系列编号递增的议案，但是最终都无法被选定，为此我们的解决方法是选择一个主 Proposer，并规定只有主 Proposer 才能提出议案。

**提案的获取**

Learner 获取一个已经被选定的提案的前提是，该提案已经被半数以上的 Acceptor 批准。因此，最简单的做法就是一旦 Acceptor 批准了一个提案，就将该提案发送给所有的 Learner。很显然，这种做法虽然可以让 Learner 尽快地获取被选定的提案，但是却需要让每个 Acceptor 与所有的 Learner 逐个进行一次通信，通信的次数至少为二者个数的乘积。

为了解决这个问题，我们可以让所有的 Acceptor 将它们对提案的批准情况，统一发送给一个特定的 Learner（下文中我们将这样的 Learner 称为 “主 Learner”），在不考虑拜占庭将军问题的前提下，我们假定 Learner 之间可以通过消息通信来互相感知提案的选定情况。基于这样的前提，当主 Learner 被通知一个提案已经被选定时，它会负责通知其他的 Learner。但是这个方案引入了新的问题就是主 Learner 故障导致的单点，解决的办法是设置多个主 Learner（或者通过选举产生新的主 Learner）。

> Paxos 算法是现代分布式系统实现的算法基础，现有分布式系统几乎都是基于此算法，此后我们将开始分布式系统的工程实践之旅



## 5 - 分布式数据一致性工业级解决方案 — Zookeeper

### 5.1 Zookeeper 从何而来

ZooKeeper 最早起源于雅虎研究院的一个研究小组。在当时，研究人员发现，在雅虎内部很多大型系统基本都需要依赖一个类似的系统来进行分布式协调，但是这些系统往往都存在分布式单点问题。所以雅虎的开发人员就试图开发一个通用的无单点问题的分布式协调框架，以便让开发人员将精力集中在处理业务逻辑上。

关于 “ZooKeeper” 这个项目的名字，其实也有一段趣闻。在立项初期，考虑到之前内部很多项目都是使用动物的名字来命名的（例如著名的 Pig 项目），雅虎的工程师希望给这个项目也取一个动物的名字。时任研究院的首席科学家 Raghu Ramakr-ishnan 开玩笑地说：“在这样下去，我们这儿就变成动物园了！”此话一出，大家纷纷表示就叫动物园管理员吧——因为各个以动物命名的分布式组件放在一起，雅虎的整个分布式系统看上去就像一个大型的动物园了，而 ZooKeeper 正好要用来进行分布式环境的协调——于是，ZooKeeper 的名字也就由此诞生了。  

### 5.2 Zookeeper 是什么

ZooKeeper 是一个开放源代码的分布式协调服务，使用 Java 语言开发，由知名互联网公司雅虎创建然后捐给 Apache，是 Google Chubby 的开源实现。

ZooKeeper 的设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。ZooKeeper 为分布式应用提供了高效且可靠的分布式协调服务，提供了诸如统一命名服务、配置管理和分布式锁等分布式的基础服务。

ZooKeeper 是一个典型的分布式数据一致性的解决方案，分布式应用程序可以基于它实现诸如**数据发布/订阅**、**负载均衡**、**命名服务**、**分布式协调/通知**、**集群管理**、**Master选举**、**分布式锁**和**分布式队列**等功能。ZooKeeper 可以保证如下分布式一致性特性：

- **顺序一致性**：同一个客户端发起的事务请求，最终将会严格地按照其发起顺序被应用到 ZooKeeper 中去。
- **原子性**：所有事务请求的处理结果在整个集群中所有机器上的应用情，况是一致的，也就是说，要么整个集群所有机器都成功应用了某一个事务，要么都没有应用。
- **单一视图**：无论客户端连接的是哪个 ZooKeeper 服务器，其看到的服务端数据模型都是一致的。
-  **可靠性**：一旦服务端成功地应用了一个事务，并完成对客户端的响应，那么该事务所引起的服务端状态变更将会被一直保留下来。
- **实时性**：这里需要注意的是，ZooKeeper 仅仅保证在一定的时间段内，客户端最终一定能够从服务端上读取到最新的数据状态。

ZooKeeper 致力于提供一个高性能、高可用，且具有严格的顺序访问控制能力（主要是写操作的严格顺序性）的分布式协调服务。高性能使得 ZooKeeper 能够应用于那些对系统吞吐有明确要求的大型分布式系统中，高可用使得分布式的单点问题得到了很好的解决，而严格的顺序访问控制使得客户端能够基于 ZooKeeper 实现一些复杂的同步原语。

### 5.3 为什么使用 Zookeeper

随着分布式架构的出现，越来越多的分布式应用会面临数据一致性问题。很遗憾的是，在解决分布式数据一致性上，除了 ZooKeeper 之外，目前还没有一个成熟稳定且被大规模应用的解决方案。ZooKeeper 无论从性能、易用性还是稳定性上来说，都已经达到了一个工业级产品的标准。

此外，Zookeeper 开源、免费、并且已经得到了广泛的应用。诸如 Hadoop、HBase、Storm 和 Solr 等越来越多的大型分布式项目都已经将 ZooKeeper 作为其核心组件，用于分布式协调。

### 5.4 Zookeeper 的基本概念

**集群角色**

ZooKeeper 没有沿用传统传统集群中的 Master/Slave 概念，而是引入了 Leader、Follower 和 Observer 三种角色。ZooKeeper 集群中的所有机器通过一个 Leader 选举过程来选定一台被称为 “Leader” 的机器，Leader 服务器为客户端提供读和写服务。除 Leader 外，其他机器包括 Follower 和 Observer。Follower 和 Observer 都能够提供读服务，唯一的区别在于，Observer 机器不参与 Leader 选举过程，也不参与写操作的 “过半写成功” 策略，因此 Observer 可以在不影响写性能的情况下提升集群的读性能。

**Session**

在 ZooKeeper 中，一个客户端连接是指客户端和服务器之间的一个 TCP 长连接。ZooKeeper 对外的服务端口默认是 2181，客户端启动的时候，首先会与服务器建立一个 TCP 连接，从第一次连接建立开始，客户端会话的生命周期也开始了，通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向 ZooKeeper 服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的 Watch 事件通知。Session 的 sessionTimeout 值用来设置一个客户端会话的超时时间。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，只要在sessionTimeout 规定的时间内能够重新连接上集群中任意一台服务器，那么之前创建的会话仍然有效。

**ZNode（数据结点）**

在ZooKeeper中，“节点” 分为两类，第一类同样是指构成集群的机器，我们称之为机器节点；第二类则是指数据模型中的数据单元，我们称之为数据节点——ZNode。ZooKeeper 将所有数据存储在内存中，数据模型是一棵树（ZNode Tree），由斜杠（/）进行分割的路径，就是一个Znode，例如 /foo/path1。每个 ZNode 上都会保存自己的数据内容，同时还会保存一系列属性信息。

在 ZooKeeper 中，ZNode 可以分为持久节点和临时节点两类。所谓持久节点是指一旦这个 ZNode 被创建了，除非主动进行 ZNode 的移除操作，否则这个 ZNode 将一直保存在 ZooKeeper 上。而临时节点就不一样了，它的生命周期和客户端会话绑定，一旦客户端会话失效，那么这个客户端创建的所有临时节点都会被移除。另外，ZooKeeper 还允许用户为每个节点添加一个特殊的属性：SEQUENTIAL。一旦节点被标记上这个属性，那么在这个节点被创建的时候，ZooKeeper 会自动在其节点名后面追加上一个整型数字，这个整型数字是一个由父节点维护的自增数字。

**版本**

ZooKeeper 的每个 ZNode 上都会存储数据，对应于每个 ZNode，ZooKeeper 都会为其维护一个叫作 Stat 的数据结构，Stat 中记录了这个 ZNode 的三个数据版本，分别是 version（当前 ZNode 的版本）、cversion（当前 ZNode 子节点的版本）和 aversion（当前 ZNode 的 ACL 版本）。

**Watcher（事件监听器）**

ZooKeeper 允许用户在指定节点上注册一些 Watcher，并且在一些特定事件触发的时候，ZooKeeper 服务端会将事件通知到感兴趣的客户端上去，该机制是 ZooKeeper 实现分布式协调服务的重要特性。

**ACL**

ZooKeeper 采用 ACL（Access Control Lists）策略来进行权限控制，类似于 UNIX 文件系统的权限控制。ZooKeeper 定义了如下5种权限： 

* CREATE：创建子节点的权限  
* READ：获取节点数据和子节点列表的权限  
* WRITE：更新节点数据的权限
* DELETE：删除子节点的权限  
* ADMIN：设置节点ACL的权限

其中尤其需要注意的是，`CREATE` 和 `DELETE` 这两种权限都是针对子节点的权限控制。

### 5.5 Zookeeper 的 ZAB 协议

事实上，ZooKeeper 并没有完全采用 Paxos 算法，而是使用了一种称为 ZooKeeperAtomic Broadcast（ZAB，ZooKeeper 原子消息广播协议）的协议作为其数据一致性的核心算法。ZAB 协议是为分布式协调服务 ZooKeeper 专门设计的一种**支持崩溃恢复**的原子广播协议。

在 ZooKeeper 中，主要依赖 ZAB 协议来实现分布式数据一致性，基于该协议，ZooKeeper 实现了一种主备模式的系统架构来保持集群中各副本之间数据的一致性。具体的，ZooKeeper 使用一个单一的主进程来接收并处理客户端的所有事务请求，并采用 ZAB 的原子广播协议，将服务器数据的状态变更以事务 Proposal 的形式广播到所有的副本进程上去。ZAB 协议的这个主备模型架构保证了同一时刻集群中只能够有一个主进程来广播服务器的状态变更，因此能够很好地处理客户端大量的并发请求。另一方面，考虑到在分布式环境中，顺序执行的一些状态变更其前后会存在一定的依赖关系，有些状态变更必须依赖于比它早生成的那些状态变更，例如变更C需要依赖变更A和变更B。这样的依赖关系也对 ZAB 协议提出了一个要求：ZAB 协议必须能够保证一个全局的变更序列被顺序应用，也就是说，ZAB 协议需要保证如果一个状态变更已经被处理了，那么所有其依赖的状态变更都应该已经被提前处理掉了。最后，考虑到主进程在任何时候都有可能出现崩溃退出或重启现象，因此，ZAB 协议还需要做到在当前主进程出现上述异常情况的时候，依旧能够正常工作。

ZAB 协议的核心是定义了对于那些会改变 ZooKeeper 服务器数据状态的事务请求的处理方式，即：所有事务请求必须由一个全局唯一的服务器来协调处理，这样的服务器被称为 Leader 服务器，而余下的其他服务器则成为 Follower 服务器。Leader 服务器负责将一个客户端事务请求转换成一个事务 Proposal（提议），并将该 Proposal 分发给集群中所有的 Follower 服务器。之后 Leader 服务器需要等待所有 Follower 服务器的反馈，一旦超过半数的 Follower 服务器进行了正确的反馈后，那么 Leader 就会再次向所有的 Follower 服务器分发 Commit 消息，要求其将前一个 Proposal 进行提交。

**ZAB 与 Paxos 算法的联系与区别**

ZAB 协议并不是 Paxos 算法的一个典型实现，在讲解 ZAB 和 Paxos 之间的区别之前，我们首先来看下两者的联系：

- 两者都存在一个类似于 Leader 进程的角色，由其负责协调多个 Follower 进程的运行。
-  Leader 进程都会等待超过半数的 Follower 做出正确的反馈后，才会将一个提案进行提交。
- 在 ZAB 协议中，每个 Proposal 中都包含了一个 epoch 值，用来代表当前的 Leader 周期，在 Paxos 算法中，同样存在这样的一个标识，只是名字变成了 Ballot。

在 Paxos 算法中，一个新选举产生的主进程会进行两个阶段的工作。第一阶段被称为读阶段，在这个阶段中，这个新的主进程会通过和所有其他进程进行通信的方式来收集上一个主进程提出的提案，并将它们提交。第二阶段被称为写阶段，在这个阶段，当前主进程开始提出它自己的提案。在 Paxos 算法设计的基础上，ZAB 协议额外添加了一个同步阶段。在同步阶段之前，ZAB 协议也存在一个和 Paxos 算法中的读阶段非常类似的过程，称为发现（Discovery）阶段。在同步阶段中，新的 Leader 会确保存在过半的 Follower 已经提交了之前 Leader 周期中的所有事务 Proposal。这一同步阶段的引入，能够有效地保证 Leader 在新的周期中提出事务 Proposal 之前，所有的进程都已经完成了对之前所有事务 Proposal 的提交。一旦完成同步阶段后，那么 ZAB 就会执行和 Paxos 算法类似的写阶段。

> 总的来讲，ZAB 协议和 Paxos 算法的本质区别在于，两者的设计目标不太一样。ZAB 协议主要用于构建一个高可用的分布式数据主备系统，例如 ZooKeeper，而 Paxos 算法则是用于构建一个分布式的一致性状态机系统。