## Redis 持久化

redis 的高性能由于所有数据都存在内存当中，为了当 redis 重启之后仍然能保证数据不丢失，那么就需要将内存中的数据同步到硬盘当中，这个我们称之为 redis 的持久化操作。



#### 两种方式：

- RDB 方式
- AOF 方式



#### 持久化使用的方式：

- RDB 持久化（默认支持，不需要配置）
  - 在指定时间间隔内将内存中的数据集快照写入硬盘，每隔30s写入硬盘
- AOF 持久化
  - 以日志的形式记录服务器所处理的每一个操作，redis 服务器启动之初，读取该文件去重新构建我们的数据库，以保证启动后数据的完整
- 无持久化
  - 通过配置来调用 redis 服务器的持久化功能
- 同时使用 RDB 和 AOF





### RDB 方式

---

#### 优势：

- 采用这种方式，Redis 数据库将会只有一个文件，这样利于文件备份，比如说打算每小时归档一次最近 24 小时的数据，同时每天归档一次最近 30 天的数据，那么可以通过这样的备份策略，一旦系统出现灾难性故障，很容易恢复；第二点，对于灾难恢复而言，RDB 是不错的选择，因为我们可以轻松地将一个单独的文件压缩后，转移到其他的存储介质当中；第三点，性能最大化，对于 Redis 的服务进程而言，在开始持久化的时候唯一需要做的只是分叉出一些进程，而后由子进程完成这些持久化工作，这样就可以极大地避免服务器进程执行 IO 操作，相比 AOF，如果数据集很大，启动效率会更高。

#### 缺点：

- 如果你想保证数据的高可用性，就是最大限度避免数据的丢失，那么 RDB 不是一个好的选择，因为系统在定时持久化之前出现问题，没来得及写，数据就丢失了。
- 由于 RDB 通过分叉的方式，子进程来协助完成数据持久化操作，因此当数据集非常大的时候，可能会导致整个服务器停止几百毫秒

#### 配置：

```
cd /usr/local/redis
ll
vim redis.conf  // 一百多行的位置
// save 900 1 这里每 900s 如果至少有 1 个 key 发生变化，会写一次
// 文件目录下的 dump.rdb 
```





### AOF 方式

---

#### 优势：

- 可以带来更高的数据安全性，redis 提供了三种同步策略（每秒同步，每修改同步，不同步），每秒同步也是异步的只是安全性不高（治不了宕机），每修改同步可以看做是是同步持久化（效率最低最安全）
- 对于日志文件写入操作 append 模式，因此在写入过程中即使出现宕机也不会破坏日志已经存在的内容，但是如果我们本次操作只是写入了一半数据，就出现了系统崩溃，不用担心，在 redis 下次启动之前我们可以通过 redis/check/aof 这个工具来帮助我们来解决数据一致性的问题。
- 如果日志过大，redis 可以自动启动重写机制，append 模式不断将修改的数据写入老的磁盘当中，同时 redis 还会创建一个新的文件来记录在此期间哪些修改命令被执行了，因此在重写切换的时候，可以更好地保证数据的安全性。
- AOF 包含一个格式非常清晰，易于理解的日志文件用于记录所有的修改操作，我们也可以通过这个文件来完成数据的重建。

#### 劣势：

- 相同数量数据集情况下，AOF 文件要比 RDB 大。
- 根据同步策略的不同，AOF 在运行效率上低于 RDB。

#### 配置：

```
vim redis.cof
// 我们发现 appendonly 是 no
// 默认情况下不打开，改成 yes 之后就能生成一个文件 appendonly.aof
// 选择同步策略，保存并退出

// 停掉 redis
./bin/redis-cli
shutdown

// 启动 redis
./bin/redis-server ./redis.conf

// 进行一些列操作
flushall  // 清空所有的 key
vim appendonly.aof
// 删除 flushall
// 启动 redis
// 还原了
```

